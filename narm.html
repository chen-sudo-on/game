<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>åƒç´ å†œåœº - æ”¾ç½®ç‰ˆ</title>
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+QingKe+HuangYou&display=swap" rel="stylesheet">
    <style>
        :root {
            --font-main: 'ZCOOL QingKe HuangYou', cursive, sans-serif;
            --bg-gradient-day: linear-gradient(135deg, #a8e6cf 0%, #dcedc1 100%);
            --bg-gradient-night: linear-gradient(135deg, #2c3e50 0%, #000000 100%);
            --bg-a: #a8e6cf;
            --bg-b: #dcedc1;
            --bg-c: #ffd3b6;
            
            --glass-bg: rgba(255, 255, 255, 0.75);
            --glass-border: rgba(255, 255, 255, 0.5);
            --glass-shadow: 0 12px 40px rgba(31, 38, 135, 0.15);
            
            --text-main: #2d3436;
            --text-muted: #636e72;
            --divider: rgba(0,0,0,0.06);
            --chip-bg: linear-gradient(to right, #ffffff, #f8f9fa);
            --chip-border: #e1e8ed;
            --tab-active-bg: #ffffff;
            
            --primary: #00b894;
            --primary-hover: #55efc4;
            --accent: #0984e3;
            --danger: #ff7675;
            --warning: #fab1a0;
            
            --card-bg: rgba(255, 255, 255, 0.6);
            --card-hover: rgba(255, 255, 255, 0.9);
            --btn-buy-bg: #00b894;
            --btn-buy-shadow: #008c70;
            --btn-buy-disabled-bg: #dfe6e9;
            
            --rows: 8;
            --cols: 10;
            --cell-min: 40px;
            --cell-max: 64px;
            --cell-size: clamp(
                var(--cell-min),
                min(
                    8vh,
                    calc((85vh - 100px) / var(--rows)),
                    calc((100vw - 400px) / var(--cols))
                ),
                var(--cell-max)
            );
        }

        body {
            font-family: var(--font-main);
            background: linear-gradient(135deg, var(--bg-a) 0%, var(--bg-b) 50%, var(--bg-c) 100%);
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: var(--text-main);
            transition: background 1.5s ease;
            overflow: hidden;
        }

        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.1); border-radius: 10px; border: 2px solid transparent; background-clip: content-box; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.2); background-clip: content-box; }
        ::-webkit-scrollbar-track { background: transparent; }

        .game-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            width: 98vw;
            max-width: 1600px;
            height: calc(100vh - 40px);
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-radius: 40px;
            box-shadow: var(--glass-shadow);
            border: 1px solid var(--glass-border);
            padding: 24px;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        /* çŠ¶æ€æ  - é‡‘å¸æ—¶é—´æ˜¾ç¤º */
        .status-bar {
            position: fixed;
            top: 12px;
            left: 12px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 6px;
            pointer-events: none;
        }

        .status-chip {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 8px 16px;
            border-radius: 18px;
            border: 1px solid var(--glass-border);
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 8px;
            pointer-events: auto;
            transition: transform 0.2s;
        }

        .status-chip:hover {
            transform: translateY(-2px);
        }

        /* é‡‘å¸æ˜¾ç¤º */
        .status-coins {
            background: linear-gradient(135deg, #fff9c4 0%, #ffe082 100%);
            border-color: #ffd54f;
            padding: 10px 18px;
            border-radius: 20px;
            box-shadow: 0 4px 12px rgba(255, 193, 7, 0.2);
        }

        .status-time {
            font-size: 12px;
            font-weight: 700;
            color: var(--text-main);
            line-height: 1.4;
            background: rgba(255,255,255,0.8);
            border-radius: 14px;
            padding: 6px 12px;
        }

        .status-coin-value {
            font-size: 20px;
            font-weight: 800;
            color: #f57f17;
            text-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .coin-icon {
            font-size: 20px;
            filter: drop-shadow(0 1px 1px rgba(0,0,0,0.15));
        }

        /* éŸ³æ•ˆæŒ‰é’® */
        .sound-btn {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            background: rgba(255,255,255,0.6);
            border: 1px solid rgba(255, 234, 167, 0.7);
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            transition: all 0.2s;
        }
        .sound-btn:active { transform: translateY(1px); }

        /* æ‚¬æµ®ä¾§è¾¹æ  */
        .left-panel-floating {
            position: fixed;
            top: 20px;
            left: -400px; /* åˆå§‹éšè— */
            width: 380px;
            height: calc(100vh - 40px);
            z-index: 100;
            transition: left 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .left-panel-floating.open {
            left: 20px;
        }

        .right-panel-floating {
            position: fixed;
            top: 20px;
            right: -400px; /* åˆå§‹éšè— */
            width: 380px;
            height: calc(100vh - 40px);
            z-index: 100;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .right-panel-floating.open {
            right: 20px;
        }

        /* æ‚¬æµ®åœ†å½¢æŒ‰é’® */
        .fab-btn {
            position: fixed;
            bottom: 40px;
            width: 64px;
            height: 64px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00b894, #0984e3);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            cursor: pointer;
            box-shadow: 0 8px 24px rgba(0, 184, 148, 0.3);
            z-index: 101;
            transition: transform 0.3s, box-shadow 0.3s, background 0.3s;
            border: 2px solid rgba(255,255,255,0.2);
        }

        .fab-btn-right { right: 40px; }
        .fab-btn-left { left: 40px; background: linear-gradient(135deg, #6c5ce7, #a29bfe); }

        .fab-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 12px 32px rgba(0, 184, 148, 0.4);
        }

        .fab-btn-left:hover {
            box-shadow: 0 12px 32px rgba(108, 92, 231, 0.4);
        }

        .fab-btn:active {
            transform: scale(0.9);
        }

        .fab-btn.active {
            background: linear-gradient(135deg, #d63031, #e17055);
        }

        .panel {
            background: var(--glass-bg);
            border-radius: 28px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            border: 1px solid var(--glass-border);
            box-shadow: 0 8px 32px rgba(0,0,0,0.05);
            height: 100%;
            min-height: 0;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .left-panel {
            background: linear-gradient(180deg, rgba(255,255,255,0.5) 0%, rgba(255,255,255,0.35) 100%);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.5);
        }

        .left-scroll {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
            margin-top: 10px;
            mask-image: linear-gradient(to bottom, transparent, black 20px, black 95%, transparent);
        }

        .brand {
            padding: 12px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 20px;
            margin-bottom: 16px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .brand-title {
            font-size: 26px;
            font-weight: 900;
            text-align: center;
            background: linear-gradient(45deg, #00b894, #00cec9);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }

        .time-display {
            font-size: 13px;
            color: var(--text-muted);
            text-align: center;
            line-height: 1.6;
            margin-top: 5px;
        }

        .coins-chip {
            background: linear-gradient(135deg, #fff9c4, #fffde7);
            border: 1px solid #fff176;
            border-radius: 20px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(251, 192, 45, 0.1);
        }

        .coin-value {
            font-size: 24px;
            color: #fbc02d;
            text-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .coin-right { display:flex; align-items:center; gap:10px; }

        .btn-soft {
            flex: 1;
            padding: 12px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            text-align: center;
            transition: 0.2s;
            background: #f1f2f6;
        }
        .btn-soft.success { background: var(--primary); color: white; }
        .btn-soft.primary { background: var(--accent); color: white; }
        .btn-soft.danger { background: var(--danger); color: white; }
        .btn-soft:hover { transform: translateY(-2px); filter: brightness(1.1); }

        /* å°è´´å£« */
        .hint-box {
            background: linear-gradient(135deg, rgba(255,255,255,0.5) 0%, rgba(255,255,255,0.3) 100%);
            border: 1px solid rgba(255,255,255,0.4);
            padding: 14px;
            border-radius: 18px;
            font-size: 13px;
            color: var(--text-muted);
            line-height: 1.6;
            margin-bottom: 14px;
        }
        .hint-box strong { color: #e67e22; display: block; margin-bottom: 4px; }
        .hint-head { display:flex; align-items:baseline; justify-content: space-between; gap: 10px; margin-bottom: 8px; }
        .hint-sub { font-size: 11px; color: var(--text-muted); white-space: nowrap; }
        .guide-scroll {
            max-height: 230px;
            overflow-y: auto;
            padding-right: 6px;
            border-radius: 12px;
            scroll-behavior: smooth;
        }
        .guide-scroll:focus { outline: 2px solid rgba(230, 126, 34, 0.25); outline-offset: 2px; }
        .guide-section { padding: 8px 10px; border-radius: 12px; background: var(--glass-bg); border: 1px solid var(--glass-border); }
        .guide-section + .guide-section { margin-top: 8px; }
        .guide-title { font-weight: 900; color: var(--text-main); font-size: 12px; margin-bottom: 4px; }
        .guide-line { font-size: 12px; color: var(--text-muted); line-height: 1.5; }
        .guide-kbd { font-weight: 900; color: rgba(9,132,227,0.95); }
        .guide-em { font-weight: 900; color: rgba(0,184,148,0.95); }

        /* å­˜æ¡£é¢æ¿ */
        .save-panel {
            background: linear-gradient(135deg, rgba(255,255,255,0.5) 0%, rgba(255,255,255,0.3) 100%);
            border-radius: 18px;
            padding: 14px;
            border: 1px solid rgba(255,255,255,0.4);
            margin-bottom: 12px;
        }
        .save-title { font-weight: bold; margin-bottom: 10px; display: flex; justify-content: space-between; font-size: 14px; }
        .save-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px; }

        /* å†œåœºä¸»åŒºåŸŸ */
        .farm-area {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: inset 0 0 20px rgba(0,0,0,0.05);
            padding: 20px;
            overflow: auto;
        }

        .farm-grid {
            display: grid;
            gap: 6px;
            width: fit-content;
            max-width: 100%;
            margin: auto;
            padding: 12px;
            background: #8d6e63;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            border: 4px solid #6d4c41;
        }
        .farm-cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: #a3c9a8;
            background-image: radial-gradient(rgba(255,255,255,0.3) 15%, transparent 16%);
            background-size: 8px 8px;
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: inset 0 -4px 0 rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: calc(var(--cell-size) * 0.6);
            user-select: none;
            border: 2px solid rgba(0,0,0,0.03);
        }

        .farm-cell:hover { 
            transform: scale(1.08) translateY(-2px); 
            z-index: 10; 
            box-shadow: 0 10px 20px rgba(0,0,0,0.1), inset 0 -4px 0 rgba(0,0,0,0.1);
            border-color: rgba(255,255,255,0.5);
        }
        .farm-cell:active { transform: scale(0.95); }

        .farm-cell.tilled {
            background-color: #d7ccc8;
            background-image: repeating-linear-gradient(45deg, #d7ccc8 0, #d7ccc8 2px, #cfd8dc 2px, #cfd8dc 4px);
            background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h40v40H0V0zm20 20h20v20H20V20zM0 20h20v20H0V20zM20 0h20v20H20V0z' fill='%238d6e63' fill-opacity='0.1' fill-rule='evenodd'/%3E");
            background-color: #a1887f;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.2);
        }

        .farm-cell.watered {
            background-color: #5d4037;
            filter: brightness(0.9);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.4);
        }

        .farm-cell.weedy {
            background-color: #a3c9a8;
            opacity: 0.9;
        }
        
        .farm-cell.locked {
            background: linear-gradient(135deg, #636e72, #2d3436);
            background-image: none;
            box-shadow: inset 0 0 0 2px rgba(255,255,255,0.08), inset 0 -4px 0 rgba(0,0,0,0.25);
            filter: grayscale(0.1) brightness(0.9);
        }
        .farm-cell.locked:hover { transform: none; box-shadow: inset 0 0 0 2px rgba(255,255,255,0.10), inset 0 -4px 0 rgba(0,0,0,0.25); }
        .farm-cell.locked:active { transform: scale(0.98); }
        .lock-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            color: rgba(255,255,255,0.95);
            text-shadow: 0 2px 8px rgba(0,0,0,0.45);
            pointer-events: none;
        }
        .lock-icon { font-size: calc(var(--cell-size) * 0.40); line-height: 1; }
        .lock-price {
            font-size: 11px;
            font-weight: 900;
            padding: 2px 6px;
            border-radius: 999px;
            background: rgba(0,0,0,0.32);
            border: 1px solid rgba(255,255,255,0.18);
            line-height: 1.2;
        }
        
        body.time-night .farm-cell.lit {
            box-shadow:
                0 0 0 2px rgba(255, 225, 150, 0.28),
                0 0 18px rgba(255, 214, 102, 0.28),
                inset 0 -4px 0 rgba(0,0,0,0.12);
            filter: brightness(1.04) saturate(1.06);
        }

        .lamp-marker {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 14px;
            line-height: 1;
            z-index: 3;
            pointer-events: none;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.35));
            opacity: 0.95;
        }

        .crop-sprite {
            filter: drop-shadow(0 4px 4px rgba(0,0,0,0.2));
            transform: translateY(-2px);
            z-index: 1;
            pointer-events: none;
        }

        .progress-bar {
            position: absolute;
            bottom: 4px;
            left: 4px;
            right: 4px;
            height: 4px;
            background: rgba(0,0,0,0.2);
            border-radius: 2px;
            overflow: hidden;
            pointer-events: none;
        }

        .progress-fill {
            height: 100%;
            background: #00b894;
            width: 0%;
            transition: width 0.3s linear;
        }
        
        .progress-text {
            position: absolute;
            bottom: 8px;
            width: 100%;
            text-align: center;
            font-size: 10px;
            color: white;
            text-shadow: 0 1px 2px black;
            font-weight: bold;
            pointer-events: none;
        }

        .tool-bar {
            background: rgba(255,255,255,0.6);
            border-radius: 20px;
            padding: 12px;
            margin-bottom: 16px;
            border: 1px solid rgba(255,255,255,0.6);
        }

        .tool-bar-head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            font-size: 14px;
            font-weight: bold;
            color: var(--text-muted);
        }

        .tool-bar-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .tool-btn {
            flex: 1;
            min-width: 44px;
            height: 56px;
            background: #fff;
            border: 1px solid #dfe6e9;
            border-bottom: 3px solid #b2bec3;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.1s;
            position: relative;
        }

        .tool-btn i { font-size: 20px; margin-bottom: 2px; font-style: normal; }
        .tool-btn span { font-size: 10px; color: var(--text-muted); }

        .tool-btn:hover { transform: translateY(-1px); }
        .tool-btn:active { transform: translateY(2px); border-bottom-width: 1px; margin-top: 2px; }

        .tool-btn.active {
            background: #ffeaa7;
            border-color: #fdcb6e;
            border-bottom-color: #e1b12c;
        }
        .tool-btn.active span { color: #d35400; font-weight: bold; }

        .tool-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            background: #ff7675;
            color: white;
            font-size: 10px;
            padding: 2px 5px;
            border-radius: 10px;
            border: 1px solid #fff;
        }

        /* æ ‡ç­¾é¡µ */
        .tabs {
            display: flex;
            background: rgba(0,0,0,0.05);
            padding: 4px;
            border-radius: 14px;
            margin-bottom: 16px;
        }

        .tab {
            flex: 1;
            padding: 8px;
            text-align: center;
            cursor: pointer;
            border-radius: 10px;
            font-size: 14px;
            color: var(--text-muted);
            transition: all 0.2s;
            font-weight: bold;
        }

        .tab.active {
            background: var(--tab-active-bg);
            color: var(--text-main);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .tab-content {
            flex: 1;
            overflow-y: auto;
            padding: 4px;
            display: none;
            min-height: 0;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
        }

        .section-title {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 10px;
            margin: 10px 0 8px;
            font-size: 13px;
            font-weight: 900;
            color: var(--text-main);
        }
        .muted {
            color: var(--text-muted);
            font-size: 11px;
            font-weight: 800;
        }

        .list-item {
            background: var(--card-bg);
            border-radius: 14px;
            padding: 10px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 12px;
            border: 1px solid rgba(255,255,255,0.6);
            transition: all 0.2s;
        }

        .list-item:hover {
            background: var(--card-hover);
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }

        .item-icon {
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.03);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }

        .item-details { flex: 1; }
        .item-name { font-weight: bold; font-size: 15px; color: var(--text-main); display: flex; align-items: center; gap: 6px; }
        .item-sub { font-size: 12px; color: var(--text-muted); margin-top: 2px; }

        .item-action {
            padding: 8px 12px;
            border-radius: 10px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-buy {
            background: var(--btn-buy-bg);
            color: white;
            box-shadow: 0 4px 0 var(--btn-buy-shadow);
        }
        .btn-buy:active { transform: translateY(4px); box-shadow: none; }
        .btn-buy:disabled { background: var(--btn-buy-disabled-bg); box-shadow: none; cursor: not-allowed; }

        .btn-sell {
            background: #fdcb6e;
            color: #d35400;
            border: 1px solid #ffeaa7;
        }
        .btn-sell:hover { background: #ffeaa7; }

        .btn-use {
            background: #74b9ff;
            color: white;
        }
        .btn-use.active { background: #0984e3; box-shadow: inset 0 2px 4px rgba(0,0,0,0.2); }

        .btn-soft {
            border: none;
            border-radius: 8px;
            padding: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
        }
        .btn-soft.success { background: #55efc4; color: #006266; }
        .btn-soft.primary { background: #74b9ff; color: #0652dd; }
        .btn-soft.danger { background: #ff7675; color: #630000; }
        .btn-soft:hover { filter: brightness(1.1); transform: translateY(-1px); }
        .btn-soft:disabled { opacity: 0.55; cursor: not-allowed; filter: none; transform: none; }

        .badge {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }

        /* å»ºç­‘åˆ—è¡¨ (å·¦ä¾§) */
        .building-strip {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 10px;
        }
        .building-tile {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 8px;
            text-align: center;
            border: 1px solid var(--glass-border);
            transition: 0.2s;
        }
        .building-tile:hover { background: var(--card-hover); transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.05); }
        .building-emoji { font-size: 24px; margin-bottom: 4px; }
        .building-name { font-size: 12px; font-weight: bold; }
        .building-sub { font-size: 10px; color: var(--text-muted); }
        .building-actions { margin-top: 6px; display: flex; justify-content: center; gap: 6px; }
        .building-mini-btn {
            font-family: inherit;
            font-size: 11px;
            font-weight: 900;
            padding: 6px 8px;
            border-radius: 10px;
            border: 1px solid var(--glass-border);
            background: var(--card-hover);
            color: var(--text-main);
            cursor: pointer;
        }
        .building-mini-btn:active { transform: translateY(1px); }
        .building-tile.placing { outline: 2px solid rgba(255, 214, 102, 0.65); box-shadow: 0 0 0 4px rgba(255, 214, 102, 0.18); }

        @media (max-width: 1180px) {
            .game-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto minmax(320px, 1fr) minmax(320px, 1fr);
                height: 100vh;
                height: 100dvh;
                border-radius: 0;
            }

            .panel { border-radius: 18px; }
            .left-panel { max-height: 320px; }
            .farm-area { padding: 12px; }
        }

        @media (max-width: 900px) {
            body {
                padding: calc(env(safe-area-inset-top) + 0px) calc(env(safe-area-inset-right) + 0px) calc(env(safe-area-inset-bottom) + 0px) calc(env(safe-area-inset-left) + 0px);
                align-items: stretch;
                min-height: 100vh;
                min-height: 100dvh;
            }
            .game-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
                height: 100vh;
                height: 100dvh;
                border-radius: 0;
                padding: 10px;
                gap: 12px;
            }
            .farm-area { order: 2; padding: 8px; }
            .panel { padding: 12px; border-radius: 16px; }
            .left-panel { order: 1; max-height: 240px; display: flex; gap: 10px; }
            .left-scroll { margin: 0; padding-right: 6px; }
            .brand { border: 0; margin: 0; padding-bottom: 0; }
            .panel:last-child { order: 3; }
            
            .left-panel > * { margin: 0 !important; }
            .save-panel { display: none; }
            .hint-box { display: block; padding: 10px; margin-bottom: 10px; }
            .guide-scroll { max-height: 140px; }
            
            .farm-grid { gap: 2px; border-width: 2px; padding: 8px; }
            :root { --cell-size: min(8.2vw, 48px); }
        }
        
        @media (max-width: 500px) {
            .tool-btn { height: 44px; min-width: 36px; }
            .tool-btn i { font-size: 18px; }
            .tool-btn span { display: none; }
        }

        .toast {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            background: rgba(45, 52, 54, 0.95);
            color: white;
            padding: 10px 20px;
            border-radius: 50px;
            z-index: 2000;
            opacity: 0;
            transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
        
        .cell-tooltip {
            position: fixed;
            z-index: 1100;
            pointer-events: none;
            opacity: 0;
            background: rgba(0,0,0,0.85);
            color: #fff;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            transition: opacity 0.2s;
            max-width: 200px;
            backdrop-filter: blur(4px);
        }
        .cell-tooltip.show { opacity: 1; }
        .tt-title { font-weight: bold; margin-bottom: 2px; color: #fab1a0; }
        .tt-sub { color: #dfe6e9; }

        .weather-layer {
            position: absolute;
            inset: 10px;
            border-radius: 20px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.25s ease;
            mix-blend-mode: soft-light;
            filter: saturate(1.05);
        }

        body.weather-rain .weather-layer {
            opacity: 0.9;
            background-image:
                linear-gradient(120deg, rgba(255,255,255,0.0) 0%, rgba(255,255,255,0.0) 55%, rgba(255,255,255,0.22) 56%, rgba(255,255,255,0.0) 58%),
                linear-gradient(120deg, rgba(255,255,255,0.0) 0%, rgba(255,255,255,0.0) 62%, rgba(255,255,255,0.18) 63%, rgba(255,255,255,0.0) 65%);
            background-size: 18px 18px, 22px 22px;
            animation: rainMove 0.45s linear infinite;
        }

        @keyframes rainMove {
            0% { background-position: 0 0, 0 0; }
            100% { background-position: -36px 54px, -44px 66px; }
        }

        body.weather-snow .weather-layer {
            opacity: 0.85;
            background-image:
                radial-gradient(circle at 10% 20%, rgba(255,255,255,0.75) 0 2px, rgba(255,255,255,0) 3px),
                radial-gradient(circle at 80% 30%, rgba(255,255,255,0.65) 0 2px, rgba(255,255,255,0) 3px),
                radial-gradient(circle at 40% 70%, rgba(255,255,255,0.55) 0 2px, rgba(255,255,255,0) 3px);
            background-size: 220px 220px;
            animation: snowFall 3.2s linear infinite;
        }

        @keyframes snowFall {
            0% { background-position: 0 -200px; }
            100% { background-position: 0 200px; }
        }

        body.weather-wind .weather-layer {
            opacity: 0.55;
            background-image: linear-gradient(90deg, rgba(255,255,255,0.0) 0%, rgba(255,255,255,0.12) 40%, rgba(255,255,255,0.0) 70%);
            background-size: 180px 100%;
            animation: windMove 1.2s ease-in-out infinite;
        }

        @keyframes windMove {
            0% { background-position: -200px 0; }
            100% { background-position: 260px 0; }
        }

        /* æ‰¹é‡å”®å–é¢æ¿ */
        .batch-sell-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(4px);
            z-index: 1500;
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.25s;
        }
        .batch-sell-overlay.show {
            display: flex;
            opacity: 1;
        }
        .batch-sell-panel {
            background: linear-gradient(180deg, rgba(255,255,255,0.95) 0%, rgba(240,240,240,0.95) 100%);
            border-radius: 24px;
            padding: 24px;
            width: 320px;
            max-width: 90vw;
            box-shadow: 0 20px 60px rgba(0,0,0,0.25);
            border: 1px solid rgba(255,255,255,0.5);
            transform: scale(0.9);
            transition: transform 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .batch-sell-overlay.show .batch-sell-panel {
            transform: scale(1);
        }
        .batch-sell-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px dashed rgba(0,0,0,0.1);
        }
        .batch-sell-title {
            font-size: 18px;
            font-weight: 900;
            color: var(--text-main);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .batch-sell-close {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: none;
            background: rgba(0,0,0,0.08);
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: 0.2s;
        }
        .batch-sell-close:hover { background: rgba(0,0,0,0.15); }
        .batch-sell-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(0,0,0,0.03);
            border-radius: 14px;
            margin-bottom: 16px;
        }
        .batch-sell-emoji {
            font-size: 36px;
        }
        .batch-sell-info {
            flex: 1;
        }
        .batch-sell-name {
            font-weight: bold;
            color: var(--text-main);
            font-size: 16px;
        }
        .batch-sell-price {
            font-size: 13px;
            color: var(--text-muted);
        }
        .batch-sell-qty-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 16px;
        }
        .batch-sell-qty-label {
            font-weight: bold;
            color: var(--text-main);
        }
        .batch-sell-qty-input {
            flex: 1;
            padding: 10px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            font-family: inherit;
            transition: 0.2s;
        }
        .batch-sell-qty-input:focus {
            outline: none;
            border-color: var(--primary);
        }
        .batch-sell-qty-btns {
            display: flex;
            gap: 6px;
        }
        .batch-sell-qty-btn {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            border: none;
            background: #e8e8e8;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: 0.2s;
        }
        .batch-sell-qty-btn:hover { background: #d0d0d0; }
        .batch-sell-qty-btn.all { background: linear-gradient(135deg, #00b894, #55efc4); color: white; }
        .batch-sell-qty-btn.all:hover { filter: brightness(1.1); }
        .batch-sell-total {
            background: linear-gradient(135deg, #fff9c4, #ffe082);
            border-radius: 14px;
            padding: 14px;
            margin-bottom: 16px;
            text-align: center;
            border: 1px solid #ffd54f;
        }
        .batch-sell-total-label {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }
        .batch-sell-total-value {
            font-size: 24px;
            font-weight: 900;
            color: #f57f17;
        }
        .batch-sell-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .batch-sell-btn {
            padding: 14px;
            border-radius: 14px;
            border: none;
            font-weight: bold;
            font-size: 15px;
            cursor: pointer;
            transition: 0.2s;
            font-family: inherit;
        }
        .batch-sell-btn.confirm {
            background: linear-gradient(135deg, #00b894, #00a884);
            color: white;
            box-shadow: 0 4px 0 #008c70;
        }
        .batch-sell-btn.confirm:active {
            transform: translateY(4px);
            box-shadow: none;
        }
        .batch-sell-btn.confirm:disabled {
            background: #dfe6e9;
            box-shadow: none;
            cursor: not-allowed;
        }
        .batch-sell-btn.cancel {
            background: #f1f2f6;
            color: var(--text-main);
        }
        .batch-sell-btn.cancel:hover { filter: brightness(0.95); }

        /* æ‰¹é‡å”®å–æŒ‰é’®æ ·å¼ */
        .btn-batch-sell {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            margin-right: 5px;
            transition: 0.2s;
            font-family: inherit;
        }
        .btn-batch-sell:hover {
            filter: brightness(1.1);
            transform: translateY(-1px);
        }
    </style>
</head>
<body>

<!-- Batch Sell Modal -->
<div id="batch-sell-overlay" class="batch-sell-overlay" onclick="BatchSell.close()">
    <div class="batch-sell-panel" onclick="event.stopPropagation()">
        <div class="batch-sell-header">
            <div class="batch-sell-title">ğŸ“¦ æ‰¹é‡å”®å–</div>
            <button class="batch-sell-close" onclick="BatchSell.close()">âœ–ï¸</button>
        </div>
        <div id="batch-sell-content"></div>
    </div>
</div>

<!-- Status Bar - Coins and Time -->
<div class="status-bar">
    <div class="status-chip status-coins">
        <span class="coin-icon">ğŸ’°</span>
        <span id="coins" class="status-coin-value">100</span>
        <button id="audio-toggle" class="sound-btn" onclick="toggleAudio()" title="éŸ³æ•ˆ">ğŸ”Š</button>
    </div>
    <div id="time-display" class="status-chip status-time"></div>
</div>

<div class="game-container">
    <!-- Center: Farm Grid -->
    <div class="farm-area">
        <div id="weather-layer" class="weather-layer" aria-hidden="true"></div>
        <div class="farm-grid" id="farm-grid"></div>
    </div>
</div>

<!-- Floating Left Panel -->
<div id="left-sidebar" class="left-panel-floating">
    <div class="panel left-panel">
        <div class="brand">
            <div class="brand-title">ğŸ’¾ å­˜æ¡£ä¸æŒ‡å—</div>
        </div>

        <div class="left-scroll">
            <div class="save-panel">
                <div class="save-title">
                    <span>ğŸ“¦ å­˜æ¡£ç®¡ç†</span>
                    <span class="muted">æœ¬æœºä¿å­˜</span>
                </div>
                <div class="save-actions">
                    <button class="btn-soft success" onclick="saveToBrowser()">âœ… ä¿å­˜</button>
                    <button class="btn-soft" onclick="loadFromBrowser()">ğŸ“¥ è¯»å–</button>
                    <button class="btn-soft primary" onclick="exportSaveFile()">â¬‡ï¸ å¯¼å‡º</button>
                    <button class="btn-soft" onclick="triggerImportSaveFile()">â¬†ï¸ å¯¼å…¥</button>
                </div>
                <input id="save-file-input" type="file" accept="application/json" style="display:none;" />
                <div style="margin-top:8px; display:flex; gap:8px;">
                    <button class="btn-soft danger" style="width:100%;" onclick="resetSave()">ğŸ—‘ï¸ é‡ç½®å­˜æ¡£</button>
                </div>
            </div>

            <div class="hint-box">
                <div class="hint-head">
                    <strong style="margin:0;">ğŸ“˜ æ¸¸æˆæŒ‡å—</strong>
                    <span class="hint-sub">è‡ªåŠ¨æ»šåŠ¨ï½œæ‚¬åœæš‚åœ</span>
                </div>
                <div id="guide-scroll" class="guide-scroll" tabindex="0" aria-label="æ¸¸æˆæŒ‡å—ï¼ˆå¯æ»šåŠ¨ï¼‰">
                    <div class="guide-section">
                        <div class="guide-title">â‘  å¼€è’ç§åœ°</div>
                        <div class="guide-line"><span class="guide-kbd">âš”ï¸</span> æ¸…æ‚è‰ â†’ <span class="guide-kbd">â›ï¸</span> å¼€å¦ â†’ åœ¨èƒŒåŒ…ç‚¹â€œä½¿ç”¨â€ç§å­ â†’ <span class="guide-kbd">ğŸ‘†</span> ç‚¹åœ°å—ç§ä¸‹</div>
                        <div class="guide-line">æ‚è‰ä¼šè‡ªå·±é•¿å‡ºæ¥ï¼šæ¸…ç†èƒ½å¾— <span class="guide-em">ğŸŒ¿</span>ï¼Œè¿˜èƒ½åšè‚¥æ–™</div>
                    </div>
                    <div class="guide-section">
                        <div class="guide-title">â‘¡ ç”Ÿé•¿åŠ é€Ÿ</div>
                        <div class="guide-line"><span class="guide-kbd">ğŸ’§</span> æµ‡æ°´ï¼šç”Ÿé•¿ <span class="guide-em">Ã—2</span>ï¼ˆæ°´äº•èƒ½è®©æµ‡æ°´æŒç»­æ›´ä¹…ï¼‰</div>
                        <div class="guide-line"><span class="guide-kbd">ğŸ§ª</span> æ–½è‚¥ï¼šç”Ÿé•¿ <span class="guide-em">Ã—1.5</span>ï¼ˆğŸŒ¿Ã—2 å¯åˆ¶è‚¥ï¼‰</div>
                        <div class="guide-line">å¤©æ°”/æ˜¼å¤œ/ä½œç‰©ç‰¹æ€§ä¹Ÿä¼šå½±å“ç”Ÿé•¿é€Ÿåº¦</div>
                    </div>
                    <div class="guide-section">
                        <div class="guide-title">â‘¢ æ”¶è·ä¸æ•´ç†</div>
                        <div class="guide-line"><span class="guide-kbd">âš”ï¸</span> æ”¶è·æˆç†Ÿä½œç‰©ï¼›<span class="guide-kbd">ğŸ§º</span> ä¸€é”®æ”¶é›†æ‰€æœ‰æˆç†Ÿä½œç‰©</div>
                        <div class="guide-line"><span class="guide-kbd">ğŸ§¹</span> é“²é™¤ä½œç‰©ä¼šå˜æˆæ‚è‰ï¼ˆå¯æ‹¿å»åˆ¶è‚¥ï¼‰</div>
                    </div>
                    <div class="guide-section">
                        <div class="guide-title">â‘£ å•†åº—ä¸å»ºç­‘</div>
                        <div class="guide-line">å•†åº—å¯ä¹°ç§å­ã€æœºå™¨äººã€ç”µæ± ã€å»ºç­‘</div>
                        <div class="guide-line"><span class="guide-em">â›²</span> æ°´äº•ï¼šæµ‡æ°´æ›´ä¹…ï¼›<span class="guide-em">ğŸŒ¬ï¸</span> é£è½¦ï¼šå–ä¸œè¥¿æ›´èµš</div>
                        <div class="guide-line"><span class="guide-em">ğŸš¿</span> å–·çŒå¡”ï¼šè‡ªåŠ¨æµ‡æ°´ï¼›<span class="guide-em">ğŸª£</span> å †è‚¥ç®±ï¼šè‡ªåŠ¨æŠŠğŸŒ¿å˜è‚¥æ–™</div>
                    </div>
                    <div class="guide-section">
                        <div class="guide-title">â‘¤ è‡ªåŠ¨åŒ–æœºå™¨äºº</div>
                        <div class="guide-line">ğŸ¤– åªä¼šæ”¶æˆç†Ÿä½œç‰©ï¼ˆæ¯æ”¶1ä¸ªè€—1ç‚¹ç”µï¼‰</div>
                        <div class="guide-line">ğŸ”‹ ç”µæ± å¯å……ç”µï¼Œç¦»çº¿ä¹Ÿèƒ½å¸®ä½ æ”¶å‰²</div>
                    </div>
                    <div class="guide-section">
                        <div class="guide-title">â‘¥ å¨æˆ¿æ–™ç†</div>
                        <div class="guide-line">å•†åº—å¯è§£é”é£Ÿè°±ï¼›å¨æˆ¿åˆ¶ä½œï¼›èƒŒåŒ…é‡Œå¯å‡ºå”®æ–™ç†</div>
                    </div>
                    <div class="guide-section">
                        <div class="guide-title">â‘¦ é…¿é…’ç©æ³•</div>
                        <div class="guide-line">å…ˆå»å•†åº—ä¹° <span class="guide-em">ğŸº é…¿é…’æ¡¶</span></div>
                        <div class="guide-line">èƒŒåŒ…é¡¶éƒ¨çš„â€œé…¿é…’æ¡¶â€é‡Œé€‰ä½œç‰©å¼€å§‹é…¿é€ ï¼ˆæ—¶é—´ä¼šæ¯”è¾ƒä¹…ï¼‰</div>
                        <div class="guide-line">å®Œæˆåç‚¹â€œå–å‡ºâ€ï¼Œé…’ä¼šè¿›èƒŒåŒ…æœ€ä¸‹æ–¹â€œğŸ· é…’â€ï¼Œå¯ç›´æ¥å‡ºå”®</div>
                    </div>
                    <div class="guide-section">
                        <div class="guide-title">â‘§ å­˜æ¡£</div>
                        <div class="guide-line">å·¦ä¾§å­˜æ¡£æ”¯æŒä¿å­˜/è¯»å–/å¯¼å…¥/å¯¼å‡º</div>
                        <div class="guide-line">å»ºè®®é‡è¦è¿›åº¦å…ˆâ€œå¯¼å‡ºâ€ä¸€ä»½å¤‡ä»½</div>
                    </div>
                </div>
            </div>

            <div class="farm-side">
                <div class="farm-side-title">
                    <span>ğŸ¡ å»ºç­‘</span>
                    <span class="muted">å†œåœºè¾¹</span>
                </div>
                <div id="building-strip" class="building-strip"></div>
            </div>
        </div>
    </div>
</div>

<!-- Floating Right Panel -->
<div id="sidebar" class="right-panel-floating">
    <div class="panel">
        <div class="tool-bar">
            <div class="tool-bar-head">
                <div class="tool-bar-title">ğŸ§° å†œå…·</div>
                <div class="tool-bar-current"><span>å½“å‰</span><span id="current-tool-label">æŸ¥çœ‹</span></div>
            </div>
            <div class="tool-bar-actions">
                <div class="tool-btn active" onclick="selectTool('hand')" data-tool="hand" title="æŸ¥çœ‹">
                    <i>ğŸ‘†</i><span>æŸ¥çœ‹</span>
                </div>
                <div class="tool-btn" onclick="selectTool('hoe')" data-tool="hoe" title="å¼€å¦">
                    <i>â›ï¸</i><span>å¼€å¦</span>
                </div>
                <div class="tool-btn" onclick="selectTool('water')" data-tool="water" title="æµ‡æ°´">
                    <i>ğŸ’§</i><span>æµ‡æ°´</span>
                </div>
                <div class="tool-btn" onclick="selectTool('scythe')" data-tool="scythe" title="æ”¶è·">
                    <i>âš”ï¸</i><span>æ”¶è·</span>
                </div>
                <div class="tool-btn" onclick="selectTool('fertilizer')" data-tool="fertilizer" title="æ–½è‚¥">
                    <i>ğŸ§ª</i><span>æ–½è‚¥</span>
                    <span id="fert-count" class="tool-badge"></span>
                </div>
                <div class="tool-btn" onclick="selectTool('basket')" data-tool="basket" title="æ”¶é›†">
                    <i>ğŸ§º</i><span>æ”¶é›†</span>
                </div>
                <div class="tool-btn" onclick="selectTool('shovel')" data-tool="shovel" title="é“²é™¤">
                    <i>ğŸ§¹</i><span>é“²é™¤</span>
                </div>
            </div>
        </div>

        <div class="tabs">
            <div class="tab active" data-tab="inventory" onclick="switchTab('inventory', this)">èƒŒåŒ…</div>
            <div class="tab" data-tab="shop" onclick="switchTab('shop', this)">å•†åº—</div>
            <div class="tab" data-tab="orders" onclick="switchTab('orders', this)">è®¢å•</div>
            <div class="tab" data-tab="kitchen" onclick="switchTab('kitchen', this)">å¨æˆ¿</div>
        </div>

        <div id="tab-inventory" class="tab-content active">
            <div id="inventory-summary"></div>
            <div id="brewery-panel"></div>
            <div id="seed-list"></div>
            <hr style="border:0; border-top:1px dashed #eee; margin:10px 0;">
            <div id="crop-list"></div>
            <hr style="border:0; border-top:1px dashed #eee; margin:10px 0;">
            <div id="food-list"></div>
            <hr style="border:0; border-top:1px dashed #eee; margin:10px 0;">
            <div id="alcohol-list"></div>
        </div>

        <div id="tab-shop" class="tab-content">
            <div id="shop-list"></div>
        </div>

        <div id="tab-orders" class="tab-content">
            <div id="order-list"></div>
        </div>

        <div id="tab-kitchen" class="tab-content">
            <div id="recipe-list"></div>
        </div>
    </div>
</div>

<!-- FAB Toggle Buttons -->
<div id="fab-left-toggle" class="fab-btn fab-btn-left" onclick="toggleLeftSidebar()" title="å­˜æ¡£ä¸æŒ‡å—">
    <span>ğŸ’¾</span>
</div>

<div id="fab-toggle" class="fab-btn fab-btn-right" onclick="toggleSidebar()" title="å·¥å…·ä¸èƒŒåŒ…">
    <span>ğŸ’</span>
</div>

<div id="toast-container"></div>
<div id="cell-tooltip" class="cell-tooltip" style="display:none;"></div>

<script>
    // --- é…ç½® ---
    const CONFIG = {
        rows: 8,
        cols: 10,
        gameLoopInterval: 1000 // 1ç§’ä¸€æ¬¡é€»è¾‘å¾ªç¯
    };

    function toggleSidebar() {
        const sidebar = document.getElementById('sidebar');
        const fab = document.getElementById('fab-toggle');
        if (!sidebar || !fab) return;
        
        sidebar.classList.toggle('open');
        fab.classList.toggle('active');
        
        const isOpen = sidebar.classList.contains('open');
        fab.querySelector('span').innerText = isOpen ? 'âœ–ï¸' : 'ğŸ’';
        
        if (isOpen) {
            playSound('buy');
        } else {
            playSound('dig');
        }
    }

    function toggleLeftSidebar() {
        const sidebar = document.getElementById('left-sidebar');
        const fab = document.getElementById('fab-left-toggle');
        if (!sidebar || !fab) return;

        sidebar.classList.toggle('open');
        fab.classList.toggle('active');

        const isOpen = sidebar.classList.contains('open');
        fab.querySelector('span').innerText = isOpen ? 'âœ–ï¸' : 'ğŸ’¾';

        if (isOpen) {
            playSound('buy');
        } else {
            playSound('dig');
        }
    }

    const SAVE = {
        version: 1,
        browserKey: 'pixel-farm-save-v1'
    };

    const WEED = {
        growMs: 25 * 60 * 1000
    };

    const SHOP = {
        robotPrice: 8888,
        batteryPrice: 180,
        batteryCharge: 25,
        robotMaxEnergy: 100
    };
    
    const LAND = {
        startRows: 5,
        startCols: 5,
        unlockBase: 80,
        unlockStep: 35
    };

    const ORDERS = {
        refreshMs: 20 * 60 * 1000,
        count: 5
    };

    const BUILDINGS = [
        { id: 'well', name: 'æ°´äº•', emoji: 'â›²', price: 1200, kind: 'functional', desc: 'æµ‡æ°´æŒç»­æ›´ä¹…' },
        { id: 'windmill', name: 'é£è½¦', emoji: 'ğŸŒ¬ï¸', price: 3200, kind: 'functional', desc: 'å‡ºå”®é¢å¤–æ”¶ç›Š' },
        { id: 'sprinkler', name: 'å–·çŒå¡”', emoji: 'ğŸš¿', price: 4800, kind: 'functional', desc: 'è‡ªåŠ¨å°èŒƒå›´æµ‡æ°´' },
        { id: 'compost', name: 'å †è‚¥ç®±', emoji: 'ğŸª£', price: 900, kind: 'functional', desc: 'è‡ªåŠ¨æŠŠæ‚è‰å˜è‚¥æ–™' },
        { id: 'brewery', name: 'é…¿é…’æ¡¶', emoji: 'ğŸº', price: 2500, kind: 'functional', desc: 'æŠŠä½œç‰©é…¿æˆé…’ï¼ˆå¾ˆä¹…ï¼‰' },
        { id: 'fence', name: 'æœ¨æ …æ ', emoji: 'ğŸªµ', price: 280, kind: 'decor', desc: 'æ‚è‰ç”Ÿé•¿æ›´æ…¢' },
        { id: 'lamp', name: 'å°ç¯ç¬¼', emoji: 'ğŸ®', price: 600, kind: 'decor', desc: 'å¤œæ™šç…§äº®å¹¶åŠ é€Ÿé™„è¿‘ä½œç‰©' }
    ];

    const SELFTEST = {
        enabled: new URLSearchParams(location.search).has('selftest'),
        mode: Number(new URLSearchParams(location.search).get('selftest') || '0') || 0
    };

    // --- æ•°æ® (50ç§ä½œç‰©) ---
    // trait: { label: æ˜¾ç¤ºæ–‡æœ¬, type: 'regrow'|'bonus', val: æ•°å€¼(å†ç”Ÿè¿›åº¦/çˆ†å‡»æ¦‚ç‡) }
    // seasons: ['spring', 'summer', 'autumn', 'winter'] (ç©ºä»£è¡¨å››å­£)
    // growth_bonus: 'day'|'night' (ç™½å¤©/å¤œæ™šç”Ÿé•¿åŠ é€Ÿ)
    const CROPS = {
        wheat: { name: "å°éº¦", emoji: "ğŸŒ¾", price: 10, sell: 15, time: 10, seasons: ['spring', 'summer'], seed_drop: { chance: 0.4, min: 1, max: 2 } },
        lettuce: { name: "ç”Ÿèœ", emoji: "ğŸ¥¬", price: 12, sell: 18, time: 12, seasons: ['spring'] },
        strawberry: { name: "è‰è“", emoji: "ğŸ“", price: 50, sell: 60, time: 45, seasons: ['spring'], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 20 } },
        tulip: { name: "éƒé‡‘é¦™", emoji: "ğŸŒ·", price: 40, sell: 60, time: 30, seasons: ['spring'] },
        dandelion: { name: "è’²å…¬è‹±", emoji: "ğŸŒ¼", price: 20, sell: 30, time: 15, seasons: ['spring'] },
        cabbage: { name: "å·å¿ƒèœ", emoji: "ğŸ¥¬", price: 30, sell: 45, time: 35, seasons: ['spring'] },
        bamboo: { name: "ç«¹ç¬‹", emoji: "ğŸ", price: 60, sell: 90, time: 50, seasons: ['spring'], trait: { label: "æé€Ÿ", type: "speed", val: 1.2 } },
        radish: { name: "ç™½èåœ", emoji: "ğŸ¥£", price: 25, sell: 38, time: 25, seasons: ['spring', 'winter'] },
        garlic: { name: "å¤§è’œ", emoji: "ğŸ§„", price: 35, sell: 53, time: 40, seasons: ['spring', 'summer'] },
        pea: { name: "è±Œè±†", emoji: "ğŸŒ±", price: 22, sell: 27, time: 20, seasons: ['spring'], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 10 } },
        coffee: { name: "å’–å•¡è±†", emoji: "â˜•", price: 100, sell: 120, time: 120, seasons: ['spring', 'summer'], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 40 } },
        kale: { name: "ç¾½è¡£ç”˜è“", emoji: "ğŸ¥¬", price: 28, sell: 42, time: 30, seasons: ['spring'] },
        corn: { name: "ç‰ç±³", emoji: "ğŸŒ½", price: 15, sell: 18, time: 20, seasons: ['summer', 'autumn'], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 30 }, seed_drop: { chance: 0.3, min: 1, max: 1 } },
        tomato: { name: "ç•ªèŒ„", emoji: "ğŸ…", price: 25, sell: 30, time: 30, seasons: ['summer'], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 30 } },
        blueberry: { name: "è“è“", emoji: "ğŸ”µ", price: 80, sell: 96, time: 80, seasons: ['summer'], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 50 } },
        pepper: { name: "è¾£æ¤’", emoji: "ğŸŒ¶ï¸", price: 35, sell: 42, time: 40, seasons: ['summer', 'autumn'], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 30 } },
        melon: { name: "ç”œç“œ", emoji: "ğŸˆ", price: 90, sell: 135, time: 80, seasons: ['summer'] },
        watermelon: { name: "è¥¿ç“œ", emoji: "ğŸ‰", price: 100, sell: 150, time: 90, seasons: ['summer'], trait: { label: "æ˜“ä¸°æ”¶", type: "bonus", val: 0.2 } },
        sunflower: { name: "å‘æ—¥è‘µ", emoji: "ğŸŒ»", price: 180, sell: 270, time: 140, seasons: ['summer', 'autumn'], trait: { label: "ç§å­å¤š", type: "bonus", val: 0.5 }, seed_drop: { chance: 0.8, min: 1, max: 3 } },
        pineapple: { name: "è è", emoji: "ğŸ", price: 150, sell: 180, time: 120, seasons: ['summer'], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 10 } },
        mango: { name: "èŠ’æœ", emoji: "ğŸ¥­", price: 110, sell: 165, time: 90, seasons: ['summer'] },
        starfruit: { name: "æ¨æ¡ƒ", emoji: "â­", price: 130, sell: 195, time: 100, seasons: ['summer'] },
        onion: { name: "æ´‹è‘±", emoji: "ğŸ§…", price: 32, sell: 48, time: 38, seasons: ['spring', 'summer'] },
        hops: { name: "å•¤é…’èŠ±", emoji: "ğŸ€", price: 55, sell: 66, time: 60, seasons: ['summer'], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 40 } },
        carrot: { name: "èƒ¡èåœ", emoji: "ğŸ¥•", price: 18, sell: 27, time: 15, seasons: ['autumn', 'spring'], trait: { label: "æ˜“ä¸°æ”¶", type: "bonus", val: 0.3 } },
        eggplant: { name: "èŒ„å­", emoji: "ğŸ†", price: 28, sell: 34, time: 35, seasons: ['autumn', 'summer'], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 30 } },
        pumpkin: { name: "å—ç“œ", emoji: "ğŸƒ", price: 120, sell: 180, time: 100, seasons: ['autumn'] },
        grape: { name: "è‘¡è„", emoji: "ğŸ‡", price: 80, sell: 96, time: 70, seasons: ['autumn'], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 40 } },
        sweet_potato: { name: "çº¢è–¯", emoji: "ğŸ ", price: 45, sell: 68, time: 50, seasons: ['autumn'] },
        yam: { name: "å±±è¯", emoji: "ğŸ¥¢", price: 50, sell: 75, time: 55, seasons: ['autumn'] },
        cranberry: { name: "è”“è¶Šè“", emoji: "ğŸ’", price: 100, sell: 120, time: 80, seasons: ['autumn'], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 20 } },
        mushroom: { name: "è˜‘è‡", emoji: "ğŸ„", price: 250, sell: 375, time: 180, seasons: ['autumn', 'spring'], trait: { label: "å¤œç”Ÿ", type: "speed", val: 2.0 }, growth_bonus: 'night' },
        apple: { name: "è‹¹æœ", emoji: "ğŸ", price: 60, sell: 72, time: 60, seasons: ['autumn'], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 50 } },
        bok_choy: { name: "å°ç™½èœ", emoji: "ğŸ¥¬", price: 20, sell: 30, time: 18, seasons: ['autumn'] },
        rose: { name: "ç«ç‘°", emoji: "ğŸŒ¹", price: 200, sell: 300, time: 150, seasons: ['spring', 'autumn'] },
        rice: { name: "æ°´ç¨»", emoji: "ğŸŒ¾", price: 25, sell: 38, time: 40, seasons: ['spring', 'summer', 'autumn'], seed_drop: { chance: 0.4, min: 1, max: 2 } },
        potato: { name: "åœŸè±†", emoji: "ğŸ¥”", price: 20, sell: 30, time: 25, seasons: ['winter', 'spring'], trait: { label: "æ˜“ä¸°æ”¶", type: "bonus", val: 0.4 } },
        spinach: { name: "è èœ", emoji: "ğŸ¥¬", price: 25, sell: 38, time: 28, seasons: ['winter'] },
        holly: { name: "å†¬é’", emoji: "ğŸ„", price: 150, sell: 225, time: 110, seasons: ['winter'] },
        crocus: { name: "ç•ªçº¢èŠ±", emoji: "ğŸŒ¸", price: 70, sell: 105, time: 55, seasons: ['winter'] },
        snowdrop: { name: "é›ªèŠ±è²", emoji: "â„ï¸", price: 90, sell: 135, time: 65, seasons: ['winter'] },
        crystal_fruit: { name: "æ°´æ™¶æœ", emoji: "ğŸ’", price: 300, sell: 450, time: 200, seasons: ['winter'], trait: { label: "å¤œç”Ÿ", type: "speed", val: 2.0 }, growth_bonus: 'night' },
        winter_root: { name: "å†¬æ ¹", emoji: "ğŸ ", price: 60, sell: 90, time: 60, seasons: ['winter'] },
        ancient_fruit: { name: "ä¸Šå¤æ°´æœ", emoji: "ğŸ”®", price: 1000, sell: 1200, time: 600, seasons: [], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 10 } },
        cactus: { name: "ä»™äººæŒ", emoji: "ğŸŒµ", price: 200, sell: 300, time: 100, seasons: [], growth_bonus: 'day' },
        mint: { name: "è–„è·", emoji: "ğŸƒ", price: 30, sell: 36, time: 25, seasons: [], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 20 } },
        basil: { name: "ç½—å‹’", emoji: "ğŸŒ¿", price: 35, sell: 53, time: 28, seasons: [] },
        rosemary: { name: "è¿·è¿­é¦™", emoji: "ğŸŒ¿", price: 45, sell: 68, time: 35, seasons: [] },
        sesame: { name: "èŠéº»", emoji: "ğŸŒ¾", price: 40, sell: 60, time: 30, seasons: [] },
        oat: { name: "ç‡•éº¦", emoji: "ğŸŒ¾", price: 38, sell: 57, time: 28, seasons: [] },
        barley: { name: "å¤§éº¦", emoji: "ğŸŒ¾", price: 42, sell: 63, time: 32, seasons: [] },
        rye: { name: "é»‘éº¦", emoji: "ğŸŒ¾", price: 46, sell: 69, time: 36, seasons: ['autumn'] },
        flax: { name: "äºšéº»", emoji: "ğŸŒ¾", price: 50, sell: 75, time: 40, seasons: [] },
        clover: { name: "ä¸‰å¶è‰", emoji: "ğŸ€", price: 55, sell: 83, time: 35, seasons: [], trait: { label: "æ˜“ä¸°æ”¶", type: "bonus", val: 0.3 } },
        sugarcane: { name: "ç”˜è”—", emoji: "ğŸ‹", price: 60, sell: 90, time: 60, seasons: ['summer', 'autumn'] },
        coconut: { name: "æ¤°å­", emoji: "ğŸ¥¥", price: 80, sell: 120, time: 60, seasons: [] },
        cacao: { name: "å¯å¯è±†", emoji: "ğŸ«", price: 120, sell: 180, time: 90, seasons: [] },
        gem_berry: { name: "å®çŸ³ç”œè“", emoji: "ğŸ’", price: 2000, sell: 3000, time: 1000, seasons: ['autumn'] },
        tea_bush: { name: "èŒ¶å¶", emoji: "ğŸµ", price: 500, sell: 600, time: 300, seasons: ['spring', 'summer', 'autumn'], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 100 } },
        banana: { name: "é¦™è•‰", emoji: "ğŸŒ", price: 95, sell: 114, time: 85, seasons: ['summer'], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 40 } },
        orange: { name: "æ©˜å­", emoji: "ğŸŠ", price: 68, sell: 82, time: 62, seasons: ['summer'], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 50 } },
        peach: { name: "æ¡ƒå­", emoji: "ğŸ‘", price: 65, sell: 78, time: 65, seasons: ['summer'], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 50 } },
        cherry: { name: "æ¨±æ¡ƒ", emoji: "ğŸ’", price: 70, sell: 84, time: 55, seasons: ['spring'], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 50 } },
        lemon: { name: "æŸ æª¬", emoji: "ğŸ‹", price: 85, sell: 102, time: 75, seasons: ['summer'], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 40 } },
        cucumber: { name: "é»„ç“œ", emoji: "ğŸ¥’", price: 30, sell: 36, time: 32, seasons: ['summer', 'autumn'], trait: { label: "å¯å†ç”Ÿ", type: "regrow", val: 30 } },
        weed: { name: "æ‚è‰", emoji: "ğŸŒ¿", price: 0, sell: 0.5, time: 0, seasons: [] }
    };

    // ä¸ºæ‰€æœ‰å¯å†ç”Ÿä½œç‰©æ·»åŠ æœ€å¤§æ”¶è·æ¬¡æ•°
    for(let k in CROPS) {
        if(CROPS[k].trait && CROPS[k].trait.type === 'regrow') {
            CROPS[k].trait.max_harvest = 5; // é»˜è®¤5æ¬¡
        }
    }

    const BREW = {
        slotCount: 3,
        fruit: new Set([
            'strawberry','blueberry','cranberry','apple','grape','mango','pineapple','starfruit',
            'melon','watermelon','banana','orange','peach','cherry','lemon','coconut','cactus','crystal_fruit',
            'ancient_fruit','gem_berry'
        ]),
        grain: new Set(['wheat','barley','oat','rye','rice','corn','sesame']),
        starchy: new Set(['potato','sweet_potato','yam','pumpkin','winter_root']),
        herb: new Set(['hops','mint','basil','rosemary','tea_bush','coffee','cacao','rose','clover'])
    };

    // --- é£Ÿè°± (20+ ç§) ---
    const RECIPES = [
        { name: "é¢åŒ…", emoji: "ğŸ", price: 70, req: { wheat: 3 } },    
        { name: "ç‰ç±³æ±¤", emoji: "ğŸ¥£", price: 90, req: { corn: 3 } },   
        { name: "è”¬èœæ²™æ‹‰", emoji: "ğŸ¥—", price: 100, req: { lettuce: 2, tomato: 1 } },
        { name: "è–¯æ¡", emoji: "ğŸŸ", price: 140, req: { potato: 3 } },  
        { name: "ç•ªèŒ„é…±", emoji: "ğŸ¥«", price: 140, req: { tomato: 3 } },
        { name: "è‰è“é…±", emoji: "ğŸ¯", price: 180, req: { strawberry: 2 } },
        { name: "æ°´æœæ‹¼ç›˜", emoji: "ğŸ§", price: 430, req: { apple: 1, banana: 1, grape: 1 } },
        { name: "å—ç“œæ´¾", emoji: "ğŸ¥§", price: 570, req: { pumpkin: 2, wheat: 1 } },
        { name: "æŠ«è¨", emoji: "ğŸ•", price: 210, req: { wheat: 2, tomato: 2, onion: 1 } },
        { name: "æ±‰å ¡", emoji: "ğŸ”", price: 120, req: { wheat: 2, lettuce: 1, tomato: 1 } },
        { name: "è¾£å‘³ç‚–èœ", emoji: "ğŸ¥˜", price: 230, req: { pepper: 2, eggplant: 1, potato: 1 } },
        { name: "æœæ±", emoji: "ğŸ¹", price: 400, req: { orange: 2, lemon: 1 } },
        { name: "è¥¿ç“œæ±", emoji: "ğŸ¥¤", price: 450, req: { watermelon: 2 } },
        { name: "è˜‘è‡æ±¤", emoji: "ğŸ²", price: 1130, req: { mushroom: 2 } },
        { name: "çƒ¤ç‰ç±³", emoji: "ğŸŒ½", price: 60, req: { corn: 2 } },   
        { name: "ä¸‰æ˜æ²»", emoji: "ğŸ¥ª", price: 80, req: { wheat: 2, lettuce: 1 } },
        { name: "è…Œé»„ç“œ", emoji: "ğŸ¥’", price: 170, req: { cucumber: 3 } },
        { name: "æ´‹è‘±åœˆ", emoji: "ğŸ§…", price: 240, req: { onion: 3, wheat: 1 } },
        { name: "ç«ç‘°èŒ¶", emoji: "ğŸµ", price: 900, req: { rose: 2 } },  
        { name: "è èç‚’é¥­", emoji: "ğŸ›", price: 360, req: { pineapple: 1, wheat: 2, carrot: 1 } },
        { name: "æ¡ƒå­æœé…±", emoji: "ğŸ‘", price: 240, req: { peach: 2 } },
        { name: "æ¨±æ¡ƒæ´¾", emoji: "ğŸ¥§", price: 280, req: { cherry: 2, wheat: 1 } },
        { name: "ç”œç“œå†°æ²™", emoji: "ğŸ§", price: 410, req: { melon: 2 } },
        { name: "èŠ±æŸ", emoji: "ğŸ’", price: 1260, req: { sunflower: 2, rose: 1 } },
        { name: "æ··åˆæœæ±", emoji: "ğŸ¹", price: 450, req: { peach: 1, cherry: 1, melon: 1 } },
        { name: "è–„è·èŒ¶", emoji: "ğŸµ", price: 110, req: { mint: 2 } },  
        { name: "é¦™è‰çƒ¤é±¼", emoji: "ğŸ–", price: 190, req: { basil: 1, rosemary: 1 } },
        { name: "èŠéº»å›¢", emoji: "ğŸ˜", price: 210, req: { sesame: 2, wheat: 1 } },
        { name: "ç‡•éº¦ç²¥", emoji: "ğŸ¥£", price: 360, req: { oat: 2, coconut: 1 } },
        { name: "å¤§éº¦é¢åŒ…", emoji: "ğŸ", price: 220, req: { barley: 2, wheat: 1 } },
        { name: "äºšéº»æ²™æ‹‰", emoji: "ğŸ¥—", price: 260, req: { flax: 2, lettuce: 1 } },
        { name: "ä¸‰å¶è‰èœœé¥®", emoji: "ğŸ¹", price: 250, req: { clover: 2 } },
        { name: "æ¤°å­å¥¶", emoji: "ğŸ¥¥", price: 360, req: { coconut: 2 } },
        { name: "çƒ­å¯å¯", emoji: "ğŸ«", price: 720, req: { cacao: 2, coconut: 1 } },
        { name: "å¯å¯è›‹ç³•", emoji: "ğŸ°", price: 590, req: { cacao: 2, wheat: 2 } },
        { name: "è–„è·å·§å…‹åŠ›", emoji: "ğŸ«", price: 380, req: { mint: 2, cacao: 1 } },
        { name: "æ¤°é¦™ç‡•éº¦é¥¼", emoji: "ğŸª", price: 360, req: { oat: 2, coconut: 1 } },
        { name: "ç½—å‹’æ±¤", emoji: "ğŸ¥£", price: 210, req: { basil: 2, tomato: 1 } },
        { name: "è¿·è¿­é¦™é¢åŒ…", emoji: "ğŸ", price: 250, req: { rosemary: 2, wheat: 2 } },
        { name: "å¯å¯è–„è·é¥®", emoji: "ğŸ¹", price: 510, req: { mint: 1, cacao: 1, coconut: 1 } },

        { name: "æ˜Ÿè¾°å¥¶æ˜”", emoji: "ğŸ¥¤", price: 2500, req: { starfruit: 2, coconut: 1 }, unlockPrice: 3200, unlocked: false },
        { name: "ä¸Šå¤æœé…¿", emoji: "ğŸ·", price: 3600, req: { ancient_fruit: 1 }, unlockPrice: 5200, unlocked: false },
        { name: "å®çŸ³æœæŒ", emoji: "ğŸ¥§", price: 5200, req: { gem_berry: 1, wheat: 2 }, unlockPrice: 8800, unlocked: false },
        { name: "å¯å¯å’–å•¡", emoji: "â˜•", price: 1800, req: { cacao: 1, coffee: 1 }, unlockPrice: 2600, unlocked: false },

        { name: "æ‰¬å·ç‚’é¥­", emoji: "ğŸš", price: 320, req: { rice: 2, carrot: 1, pea: 1, onion: 1 } },
        { name: "è’œè“‰è èœ", emoji: "ğŸ¥¬", price: 210, req: { spinach: 2, garlic: 1 } },
        { name: "æ¸…ç‚’å°ç™½èœ", emoji: "ğŸ¥¬", price: 180, req: { bok_choy: 2, garlic: 1 } },
        { name: "é…¸è¾£åœŸè±†ä¸", emoji: "ğŸ¥”", price: 240, req: { potato: 2, pepper: 1, garlic: 1 } },
        { name: "é±¼é¦™èŒ„å­", emoji: "ğŸ†", price: 360, req: { eggplant: 2, pepper: 1, garlic: 1 } },
        { name: "ç«¹ç¬‹è˜‘è‡ç…²", emoji: "ğŸ²", price: 820, req: { bamboo: 1, mushroom: 1, garlic: 1 } },
        { name: "è‘±æ²¹é¥¼", emoji: "ğŸ«“", price: 260, req: { wheat: 2, onion: 1, sesame: 1 } },
        { name: "éº»è¾£å·å¿ƒèœ", emoji: "ğŸ¥¬", price: 260, req: { cabbage: 2, pepper: 1, garlic: 1 } },
        { name: "è…Šå…«ç²¥", emoji: "ğŸ¥£", price: 420, req: { rice: 2, oat: 1, barley: 1, cranberry: 1 } },
        { name: "ç«ç‘°èŠ±èŒ¶", emoji: "ğŸµ", price: 520, req: { tea_bush: 1, rose: 1 } },

        { name: "åœ°ä¸‰é²œ", emoji: "ğŸ¥˜", price: 520, req: { potato: 1, eggplant: 1, pepper: 1 } },
        { name: "å‡‰æ‹Œé»„ç“œ", emoji: "ğŸ¥’", price: 160, req: { cucumber: 2, garlic: 1 } },
        { name: "é¦™è‡ç™½èœ", emoji: "ğŸ¥¬", price: 420, req: { cabbage: 2, mushroom: 1, garlic: 1 } },
        { name: "ç«¹ç¬‹ç‚’å°ç™½èœ", emoji: "ğŸ¥¬", price: 360, req: { bamboo: 1, bok_choy: 2, garlic: 1 } },
        { name: "è¥¿çº¢æŸ¿ç‚–åœŸè±†", emoji: "ğŸ²", price: 380, req: { tomato: 2, potato: 1, onion: 1 } },
        { name: "è’œé¦™èŒ„å­", emoji: "ğŸ†", price: 320, req: { eggplant: 2, garlic: 1 } },
        { name: "é’æ¤’ç‚’é¥­", emoji: "ğŸš", price: 280, req: { rice: 2, pepper: 1, onion: 1 } },
        { name: "å—ç“œç²¥", emoji: "ğŸ¥£", price: 340, req: { rice: 2, pumpkin: 1 } },
        { name: "èŒè‡ç²¥", emoji: "ğŸ¥£", price: 520, req: { rice: 2, mushroom: 1, onion: 1 } },
        { name: "çº¢è–¯é¥¼", emoji: "ğŸ¥", price: 360, req: { sweet_potato: 2, wheat: 1, sesame: 1 } },
        { name: "èŠéº»é…±æ‹Œé¢", emoji: "ğŸœ", price: 420, req: { wheat: 2, sesame: 2, cucumber: 1 } },
        { name: "é…¸è¾£å°ç™½èœ", emoji: "ğŸ¥¬", price: 260, req: { bok_choy: 2, pepper: 1, garlic: 1 } },
        { name: "èƒ¡èåœç‚’è±Œè±†", emoji: "ğŸ¥•", price: 260, req: { carrot: 2, pea: 2 } },
        { name: "ç‰ç±³è±Œè±†ä¸", emoji: "ğŸŒ½", price: 280, req: { corn: 2, pea: 2, carrot: 1 } },
        { name: "ç™½èåœç‚–è˜‘è‡", emoji: "ğŸ²", price: 560, req: { radish: 2, mushroom: 1, garlic: 1 } },
        { name: "è‘±çƒ§èŒ„å­", emoji: "ğŸ†", price: 380, req: { eggplant: 2, onion: 2, garlic: 1 } },
        { name: "æ¸…ç‚’ç¾½è¡£ç”˜è“", emoji: "ğŸ¥¬", price: 240, req: { kale: 2, garlic: 1 } },
        { name: "é¦™è¾£èŒ„å­åœŸè±†", emoji: "ğŸ¥˜", price: 460, req: { eggplant: 1, potato: 1, pepper: 2 } },
        { name: "é†‹æºœåœŸè±†ç‰‡", emoji: "ğŸ¥”", price: 260, req: { potato: 2, onion: 1, garlic: 1 } },
        { name: "è’œè“‰ç«¹ç¬‹", emoji: "ğŸ", price: 280, req: { bamboo: 2, garlic: 1 } }
    ];

    function idxToRowCol(idx) {
        const r = Math.floor(idx / CONFIG.cols);
        const c = idx % CONFIG.cols;
        return { r, c };
    }

    function isLandInitiallyUnlocked(idx) {
        const { r, c } = idxToRowCol(idx);
        return r >= 0 && c >= 0 && r < LAND.startRows && c < LAND.startCols;
    }

    function getLandUnlockPrice(idx) {
        const { r, c } = idxToRowCol(idx);
        const dr = Math.max(0, r - (LAND.startRows - 1));
        const dc = Math.max(0, c - (LAND.startCols - 1));
        const dist = dr + dc;
        const band = Math.max(1, Math.ceil(dist / 2));
        return LAND.unlockBase + LAND.unlockStep * band;
    }

    function createInitialFarm() {
        const now = Date.now();
        const n = CONFIG.rows * CONFIG.cols;
        const farm = [];
        for (let i = 0; i < n; i++) {
            const unlocked = isLandInitiallyUnlocked(i);
            farm.push({
                locked: !unlocked,
                type: 'wild',
                cropId: null,
                progress: 0,
                waterUntil: 0,
                fertilized: false,
                harvestCount: 0,
                weed: unlocked,
                emptySince: now
            });
        }
        return farm;
    }

    // --- çŠ¶æ€ ---
    let state = {
        coins: 100,
        tool: 'hand',
        selectedSeed: null,
        inventory: {
            seeds: {}, // id: count
            crops: {}, 
            foods: {},
            alcohols: {},
            fertilizer: 5,
            batteries: 0
        },
        robot: {
            owned: false,
            energy: 0,
            maxEnergy: SHOP.robotMaxEnergy
        },
        buildings: {
            owned: {},
            sprinklerNextAt: 0,
            compostNextAt: 0,
            placed: {
                lamp: []
            },
            placeMode: null
        },
        brewery: {
            slots: []
        },
        orders: {
            nextRefreshAt: 0,
            list: []
        },
        // åœ°å—æ•°æ®: { type: 'wild'|'tilled', cropId: null, plantedAt: timestamp, waterUntil: timestamp, progress: 0-100, harvestCount: 0 }
        farm: createInitialFarm()
    };

    // --- åˆå§‹åŒ– ---
    function init() {
        loadAudioSetting();

        const browserSave = localStorage.getItem(SAVE.browserKey);
        if (browserSave) {
            const shouldLoad = SELFTEST.enabled ? true : confirm('æ£€æµ‹åˆ°æµè§ˆå™¨æœ¬åœ°å­˜æ¡£ï¼Œæ˜¯å¦è¯»å–ï¼Ÿ');
            if (shouldLoad) {
                try {
                    applySaveData(JSON.parse(browserSave));
                    showToast('å·²è¯»å–æœ¬åœ°å­˜æ¡£', 'success');
                } catch {
                    showToast('æœ¬åœ°å­˜æ¡£æŸåï¼Œè¯»å–å¤±è´¥');
                }
            }
        }

        // åˆå§‹èµ é€ç§å­ï¼šéšæœº5ä¸ªå…¨å­£ä½œç‰©
        if (Object.keys(state.inventory.seeds).length === 0) {
            const allSeasonCrops = Object.keys(CROPS).filter(k => CROPS[k].seasons && CROPS[k].seasons.length === 0);
            if (allSeasonCrops.length > 0) {
                for (let i = 0; i < 5; i++) {
                    const randomCrop = allSeasonCrops[Math.floor(Math.random() * allSeasonCrops.length)];
                    state.inventory.seeds[randomCrop] = (state.inventory.seeds[randomCrop] || 0) + 1;
                }
                showToast("è·å¾—æ–°æ‰‹ç¤¼åŒ…ï¼š5ä¸ªå…¨å­£ç§å­ï¼", "success");
            }
        }

        document.documentElement.style.setProperty('--rows', String(CONFIG.rows));
        document.documentElement.style.setProperty('--cols', String(CONFIG.cols));

        // è®¾ç½®ç½‘æ ¼å¸ƒå±€
        const grid = document.getElementById('farm-grid');
        grid.style.gridTemplateColumns = `repeat(${CONFIG.cols}, var(--cell-size))`;
        grid.style.gridTemplateRows = `repeat(${CONFIG.rows}, var(--cell-size))`;
        
        // æ¸²æŸ“åœ°å—
        state.farm.forEach((_, i) => {
            const cell = document.createElement('div');
            cell.className = 'farm-cell';
            cell.dataset.index = i;
            cell.onclick = () => onCellClick(i);
            cell.onmouseenter = (e) => showCellTooltip(i, e.clientX, e.clientY);
            cell.onmousemove = (e) => showCellTooltip(i, e.clientX, e.clientY);
            cell.onmouseleave = () => hideCellTooltip();
            cell.ontouchstart = (e) => {
                if (e.touches && e.touches[0]) {
                    showCellTooltip(i, e.touches[0].clientX, e.touches[0].clientY, true);
                }
            };
            cell.ontouchend = () => hideCellTooltip();
            
            // è¿›åº¦å®¹å™¨
            const container = document.createElement('div');
            container.className = 'progress-container';
            container.style.display = 'none'; // é»˜è®¤éšè—
            
            const text = document.createElement('div');
            text.className = 'progress-text';
            
            const bar = document.createElement('div');
            bar.className = 'progress-bar';
            bar.innerHTML = '<div class="progress-fill"></div>';
            
            container.appendChild(text);
            container.appendChild(bar);
            cell.appendChild(container);

            grid.appendChild(cell);
        });

        // å¯åŠ¨å¾ªç¯
        setInterval(gameLoop, CONFIG.gameLoopInterval);

        setInterval(() => {
            try { autoSaveTick(); } catch {}
        }, 15000);

        window.addEventListener('beforeunload', () => {
            try { autoSaveTick(); } catch {}
        });
        
        // ç¯å¢ƒæ£€æµ‹ (æ¯ç§’æ›´æ–°)
        setInterval(updateEnvironment, 1000);
        updateEnvironment();

        {
            const el = document.getElementById('time-display');
            if (el) {
                el.style.cursor = 'pointer';
                el.onclick = () => cycleThemePreview();
                el.oncontextmenu = (e) => {
                    e.preventDefault();
                    themePreview = null;
                    themePreviewIndex = -1;
                    updateEnvironment();
                    showToast('å·²é€€å‡ºä¸»é¢˜é¢„è§ˆ', 'success');
                };
            }
        }

        initWeather();

        // åˆå§‹æ¸²æŸ“
        renderAll();
        renderAudioToggle();
        initGuideScroll();
        showToast("âœ¨ æ¬¢è¿æ¥åˆ°åƒç´ å†œåœºï¼");

        if (SELFTEST.enabled) {
            setTimeout(() => {
                try {
                    runSelfTests(SELFTEST.mode);
                } catch (e) {
                    console.error('SELFTEST FAILED', e);
                }
            }, 50);
        }
    }

    const guideScrollState = {
        timer: 0,
        paused: false,
        lastUserAt: 0
    };

    function initGuideScroll() {
        const el = document.getElementById('guide-scroll');
        if (!el) return;

        if (guideScrollState.timer) {
            try { clearInterval(guideScrollState.timer); } catch {}
        }

        const pause = () => { guideScrollState.paused = true; };
        const resume = () => { guideScrollState.paused = false; };
        const user = () => { guideScrollState.lastUserAt = Date.now(); };

        el.addEventListener('mouseenter', pause);
        el.addEventListener('mouseleave', resume);
        el.addEventListener('focusin', pause);
        el.addEventListener('focusout', resume);
        el.addEventListener('wheel', user, { passive: true });
        el.addEventListener('touchstart', pause, { passive: true });
        el.addEventListener('touchend', resume, { passive: true });
        el.addEventListener('scroll', user, { passive: true });
        el.addEventListener('pointerdown', pause, { passive: true });
        el.addEventListener('pointerup', resume, { passive: true });

        guideScrollState.timer = setInterval(() => {
            try {
                if (guideScrollState.paused) return;
                if (Date.now() - guideScrollState.lastUserAt < 2500) return;
                if (el.scrollHeight <= el.clientHeight + 2) return;

                const next = el.scrollTop + 1;
                const max = el.scrollHeight - el.clientHeight;
                if (next >= max - 1) {
                    el.scrollTop = 0;
                } else {
                    el.scrollTop = next;
                }
            } catch {}
        }, 40);
    }

    function assertOk(cond, msg) {
        if (!cond) throw new Error(msg || 'assert_failed');
    }

    function runSelfTests(mode) {
        const t0 = Date.now();
        console.warn(`SELFTEST START mode=${mode}`);

        if (mode === 1) {
            localStorage.removeItem(SAVE.browserKey);

            state.coins = 999999;
            buyRobot();
            assertOk(state.robot.owned === true, 'robot_not_owned');
            assertOk((state.robot.energy || 0) > 0, 'robot_no_energy');

            const prevB = state.inventory.batteries || 0;
            buyBattery();
            assertOk((state.inventory.batteries || 0) === prevB + 1, 'battery_not_bought');
            const prevE = state.robot.energy || 0;
            useBattery();
            assertOk((state.robot.energy || 0) >= prevE, 'battery_not_charged');

            const idx = 0;
            state.farm[idx].type = 'tilled';
            state.farm[idx].weed = false;
            state.farm[idx].cropId = 'wheat';
            state.farm[idx].progress = 100;
            const before = state.inventory.crops.wheat || 0;
            state.robot.energy = 2;
            const harvested = robotHarvestTick(true);
            assertOk(harvested >= 1, 'robot_not_harvest');
            assertOk((state.inventory.crops.wheat || 0) >= before + 1, 'harvest_not_added');
            assertOk((state.robot.energy || 0) === 1, 'energy_not_consumed');
        } else if (mode === 2) {
            state.coins = 999999;
            const lockedIdx = RECIPES.findIndex(r => r && r.unlockPrice && !r.unlocked);
            assertOk(lockedIdx >= 0, 'no_locked_recipe');
            const r = RECIPES[lockedIdx];
            craft(lockedIdx);
            const beforeFoods = state.inventory.foods[lockedIdx] || 0;
            assertOk(beforeFoods === 0, 'locked_recipe_crafted');
            buyRecipeUnlock(lockedIdx);
            assertOk(r.unlocked === true, 'recipe_not_unlocked');
        } else if (mode === 3) {
            state.coins = 999999;
            state.robot.owned = true;
            state.robot.maxEnergy = SHOP.robotMaxEnergy;
            state.robot.energy = 20;

            const idx = 1;
            state.farm[idx].type = 'tilled';
            state.farm[idx].weed = false;
            state.farm[idx].cropId = 'wheat';
            state.farm[idx].progress = 98;
            state.farm[idx].fertilized = true;
            state.farm[idx].waterUntil = Date.now() + 9000;

            const data = buildSaveData();
            data.savedAt = Date.now() - 60000;
            data.farm[idx].progress = 60;
            data.farm[idx].waterRemaining = 10;

            const wheatBefore = state.inventory.crops.wheat || 0;
            applySaveData(data);
            const wheatAfter = state.inventory.crops.wheat || 0;
            const harvested = wheatAfter > wheatBefore;
            const progressed = state.farm[idx].cropId ? (state.farm[idx].progress >= 60) : true;
            assertOk(harvested || progressed, 'offline_progress_or_harvest_failed');
            assertOk(state.robot.energy <= 20, 'offline_energy_not_consumed');
        } else if (mode === 4) {
            state.coins = 999999;
            const idx = RECIPES.length - 1;
            const r = RECIPES[idx];
            for (let ing in r.req) {
                state.inventory.crops[ing] = (state.inventory.crops[ing] || 0) + r.req[ing];
            }
            const beforeCoins = state.coins;
            craft(idx);
            assertOk((state.inventory.foods[idx] || 0) >= 1, 'food_not_crafted');
            sellFood(idx);
            assertOk(state.coins > beforeCoins, 'food_not_sold');
        } else {
            assertOk(true, 'noop');
        }

        renderAll();
        updateFarmVisuals();
        console.warn(`SELFTEST PASS mode=${mode} in ${Date.now() - t0}ms`);
    }

    function buildSaveData() {
        const now = Date.now();
        return {
            version: SAVE.version,
            savedAt: now,
            rows: CONFIG.rows,
            cols: CONFIG.cols,
            coins: state.coins,
            inventory: {
                seeds: state.inventory.seeds,
                crops: state.inventory.crops,
                foods: state.inventory.foods,
                alcohols: state.inventory.alcohols || {},
                fertilizer: state.inventory.fertilizer,
                batteries: state.inventory.batteries || 0
            },
            robot: {
                owned: !!state.robot?.owned,
                energy: state.robot?.energy || 0,
                maxEnergy: state.robot?.maxEnergy || SHOP.robotMaxEnergy
            },
            buildingsOwned: state.buildings?.owned || {},
            buildingsPlaced: state.buildings?.placed || { lamp: [] },
            brewery: state.brewery || { slots: [] },
            orders: state.orders || { nextRefreshAt: 0, list: [] },
            recipesUnlocked: RECIPES
                .map((r, idx) => ({ r, idx }))
                .filter(x => x.r && x.r.unlockPrice && x.r.unlocked)
                .map(x => x.idx),
            farm: state.farm.map(c => {
                const waterRemaining = c.waterUntil && c.waterUntil > now ? Math.ceil((c.waterUntil - now) / 1000) : 0;
                return {
                    locked: !!c.locked,
                    type: c.type || 'wild',
                    cropId: c.cropId || null,
                    progress: c.progress || 0,
                    fertilized: !!c.fertilized,
                    harvestCount: c.harvestCount || 0,
                    weed: !!c.weed,
                    waterRemaining: c.locked ? 0 : waterRemaining,
                    emptySince: typeof c.emptySince === 'number' ? c.emptySince : (c.cropId ? 0 : now)
                };
            })
        };
    }

    function applySaveData(data) {
        if (!data || typeof data !== 'object') throw new Error('bad_save');
        if (data.version !== SAVE.version) throw new Error('bad_version');

        state.coins = typeof data.coins === 'number' ? data.coins : 100;

        const inv = data.inventory || {};
        state.inventory.seeds = inv.seeds && typeof inv.seeds === 'object' ? inv.seeds : {};
        state.inventory.crops = inv.crops && typeof inv.crops === 'object' ? inv.crops : {};
        state.inventory.foods = inv.foods && typeof inv.foods === 'object' ? inv.foods : {};
        state.inventory.alcohols = inv.alcohols && typeof inv.alcohols === 'object' ? inv.alcohols : {};
        state.inventory.fertilizer = typeof inv.fertilizer === 'number' ? inv.fertilizer : (state.inventory.fertilizer || 0);
        state.inventory.batteries = typeof inv.batteries === 'number' ? inv.batteries : (state.inventory.batteries || 0);

        const robot = data.robot || {};
        state.robot.owned = !!robot.owned;
        state.robot.maxEnergy = typeof robot.maxEnergy === 'number' ? robot.maxEnergy : SHOP.robotMaxEnergy;
        state.robot.energy = typeof robot.energy === 'number' ? Math.max(0, Math.min(state.robot.maxEnergy, robot.energy)) : 0;

        const ownedBuildings = data.buildingsOwned && typeof data.buildingsOwned === 'object' ? data.buildingsOwned : {};
        state.buildings.owned = ownedBuildings;
        state.buildings.sprinklerNextAt = 0;
        state.buildings.compostNextAt = 0;
        state.buildings.placed = sanitizeBuildingsPlaced(data.buildingsPlaced, getBuildingCount('lamp'));
        state.buildings.placeMode = null;

        state.brewery = sanitizeBreweryState(data.brewery);

        const unlocked = Array.isArray(data.recipesUnlocked) ? data.recipesUnlocked : [];
        RECIPES.forEach((r, idx) => {
            if (r && r.unlockPrice) r.unlocked = unlocked.includes(idx);
        });

        const now = Date.now();
        const savedAt = typeof data.savedAt === 'number' ? data.savedAt : now;
        const offlineSec = Math.max(0, Math.floor((now - savedAt) / 1000));

        state.orders = sanitizeOrdersState(data.orders, now);

        const list = Array.isArray(data.farm) ? data.farm : [];
        const saveHasLockedFlag = list.some(x => x && typeof x.locked === 'boolean');
        const targetLen = CONFIG.rows * CONFIG.cols;
        const farm = [];
        for (let i = 0; i < targetLen; i++) {
            const c = list[i] || {};
            const locked = saveHasLockedFlag ? (typeof c.locked === 'boolean' ? c.locked : false) : false;
            if (locked) {
                farm.push({
                    locked: true,
                    type: 'wild',
                    cropId: null,
                    progress: 0,
                    waterUntil: 0,
                    fertilized: false,
                    harvestCount: 0,
                    weed: false,
                    emptySince: now
                });
                continue;
            }
            const waterRemainingSaved = typeof c.waterRemaining === 'number' ? c.waterRemaining : 0;
            const waterBoostSec = Math.min(waterRemainingSaved, offlineSec);
            const waterRemainingNow = Math.max(0, waterRemainingSaved - offlineSec);

            const cropId = c.cropId && CROPS[c.cropId] ? c.cropId : null;
            let progress = typeof c.progress === 'number' ? Math.max(0, Math.min(100, c.progress)) : 0;
            const fertilized = !!c.fertilized;
            const harvestCount = typeof c.harvestCount === 'number' ? c.harvestCount : 0;
            const emptySinceSaved = typeof c.emptySince === 'number' ? c.emptySince : now;
            let weed = !!c.weed;
            const type = c.type === 'tilled' ? 'tilled' : 'wild';

            if (cropId && progress < 100 && offlineSec > 0) {
                const crop = CROPS[cropId];
                let baseMultiplier = 1;
                if (fertilized) baseMultiplier *= 1.5;
                if (crop.trait && crop.trait.type === 'speed' && typeof crop.trait.val === 'number') baseMultiplier *= crop.trait.val;
                if (crop.growth_bonus) {
                    if (crop.growth_bonus === 'night' && isNight) baseMultiplier *= 2;
                    if (crop.growth_bonus === 'day' && !isNight) baseMultiplier *= 2;
                }

                baseMultiplier *= getWeatherGrowthMultiplier();
                const baseRate = crop.time > 0 ? (100 / crop.time) * baseMultiplier : 0;
                progress = Math.min(100, progress + baseRate * offlineSec + baseRate * waterBoostSec);
                if (progress >= 100) progress = 100;
            }

            const emptySince = cropId ? 0 : emptySinceSaved;
            if (!cropId && !weed && now - emptySince >= getWeedGrowMs()) weed = true;

            farm.push({
                locked: false,
                type,
                cropId,
                progress,
                waterUntil: waterRemainingNow > 0 ? now + Math.ceil(waterRemainingNow) * 1000 : 0,
                fertilized,
                harvestCount,
                weed,
                emptySince
            });
        }
        state.farm = farm;

        if (offlineSec > 0 && state.robot.owned && (state.robot.energy || 0) > 0) {
            const beforeEnergy = state.robot.energy || 0;
            const harvested = robotHarvestTick(true, false);
            const used = beforeEnergy - (state.robot.energy || 0);
            if (harvested > 0) showToast(`ç¦»çº¿æ”¶å‰²ï¼š${harvested}ï¼ˆè€—ç”µ ${used}ï¼‰`, 'success');
        }
    }

    function autoSaveTick() {
        const data = buildSaveData();
        localStorage.setItem(SAVE.browserKey, JSON.stringify(data));
    }

    function saveToBrowser() {
        autoSaveTick();
        showToast('å·²ä¿å­˜åˆ°æµè§ˆå™¨', 'success');
    }

    function loadFromBrowser() {
        const raw = localStorage.getItem(SAVE.browserKey);
        if (!raw) {
            showToast('æ²¡æœ‰æ‰¾åˆ°æµè§ˆå™¨å­˜æ¡£');
            return;
        }
        try {
            applySaveData(JSON.parse(raw));
            renderAll();
            updateFarmVisuals();
            showToast('å·²è¯»å–æµè§ˆå™¨å­˜æ¡£', 'success');
        } catch {
            showToast('æµè§ˆå™¨å­˜æ¡£æŸåï¼Œè¯»å–å¤±è´¥');
        }
    }

    function exportSaveFile() {
        const data = buildSaveData();
        const str = JSON.stringify(data, null, 2);
        const blob = new Blob([str], { type: 'application/json' });
        const a = document.createElement('a');
        const now = new Date();
        const pad = (n) => String(n).padStart(2, '0');
        const name = `pixel-farm-save-${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}.json`;
        a.href = URL.createObjectURL(blob);
        a.download = name;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(a.href);
        showToast('å·²å¯¼å‡ºå­˜æ¡£æ–‡ä»¶', 'success');
    }

    function triggerImportSaveFile() {
        const input = document.getElementById('save-file-input');
        if (!input) return;
        input.value = '';
        input.click();
    }

    function handleImportFile(file) {
        const reader = new FileReader();
        reader.onload = () => {
            try {
                const data = JSON.parse(String(reader.result || ''));
                applySaveData(data);
                renderAll();
                updateFarmVisuals();
                showToast('å¯¼å…¥æˆåŠŸ', 'success');
            } catch {
                showToast('å¯¼å…¥å¤±è´¥ï¼šä¸æ˜¯æœ‰æ•ˆå­˜æ¡£');
            }
        };
        reader.readAsText(file);
    }

    function resetSave() {
        const ok = confirm('ç¡®å®šè¦é‡ç½®å­˜æ¡£å—ï¼Ÿè¿™ä¼šæ¸…ç©ºæµè§ˆå™¨å­˜æ¡£å¹¶åˆ·æ–°æ¸¸æˆã€‚');
        if (!ok) return;
        localStorage.removeItem(SAVE.browserKey);
        location.reload();
    }

    let tooltipHideTimer = null;
    function showCellTooltip(idx, clientX, clientY, isTouch = false) {
        const el = document.getElementById('cell-tooltip');
        if (!el) return;

        if (tooltipHideTimer) {
            clearTimeout(tooltipHideTimer);
            tooltipHideTimer = null;
        }

        const c = state.farm[idx];
        let title = '';
        let sub = '';

        if (c.locked) {
            title = 'ğŸ”’ æœªè§£é”åœŸåœ°';
            sub = `ç‚¹å‡»è§£é”ï¼š${getLandUnlockPrice(idx)}é‡‘`;
        }
        else if (c.cropId) {
            const crop = CROPS[c.cropId];
            const p = Math.max(0, Math.min(100, c.progress || 0));
            title = `${crop.emoji} ${crop.name}`;

            if (p >= 100) sub = 'å·²æˆç†Ÿï¼šå¯æ”¶è·';
            else sub = `ç”Ÿé•¿ä¸­ï¼š${Math.floor(p)}%`;

            const tags = [];
            if (c.waterUntil > Date.now()) tags.push('å·²æµ‡æ°´');
            if (c.fertilized) tags.push('å·²æ–½è‚¥');
            if (isNight && isCellLit(idx)) tags.push('ç¯å…‰');
            if (getLunarCropBonus(c.cropId).active) tags.push('å†œå†æ—º');
            if (crop.trait && crop.trait.type === 'regrow') {
                tags.push(`æ”¶è·ï¼š${c.harvestCount || 0}/${crop.trait.max_harvest}`);
            }
            if (tags.length) sub += `ï¼ˆ${tags.join(' / ')}ï¼‰`;
        } else if (c.weed) {
            title = `${CROPS.weed.emoji} æ‚è‰`;
            sub = 'ç”¨âš”ï¸æ¸…ç†ï¼ˆæˆ–ğŸ§ºä¸€é”®æ¸…ç†ï¼‰';
        } else {
            if (c.type === 'tilled') {
                title = 'ğŸŸ« å·²å¼€å¦åœŸåœ°';
                sub = 'å¯ä»¥æ’­ç§';
            } else {
                title = 'ğŸŸ¨ è’åœ°';
                sub = 'ç”¨â›ï¸å¼€å¦';
            }
        }

        el.innerHTML = `<div class="tt-title">${escapeHtml(title)}</div><div class="tt-sub">${escapeHtml(sub)}</div>`;
        el.style.display = 'block';
        el.classList.add('show');

        const margin = 12;
        const { innerWidth: vw, innerHeight: vh } = window;
        const rect = el.getBoundingClientRect();
        let x = clientX + 14;
        let y = clientY + 14;
        if (x + rect.width + margin > vw) x = vw - rect.width - margin;
        if (y + rect.height + margin > vh) y = vh - rect.height - margin;
        if (x < margin) x = margin;
        if (y < margin) y = margin;
        el.style.left = `${x}px`;
        el.style.top = `${y}px`;

        if (isTouch) {
            tooltipHideTimer = setTimeout(() => hideCellTooltip(), 1200);
        }
    }

    function hideCellTooltip() {
        const el = document.getElementById('cell-tooltip');
        if (!el) return;
        if (tooltipHideTimer) {
            clearTimeout(tooltipHideTimer);
            tooltipHideTimer = null;
        }
        el.classList.remove('show');
        el.style.display = 'none';
    }

    function escapeHtml(str) {
        return String(str)
            .replaceAll('&', '&amp;')
            .replaceAll('<', '&lt;')
            .replaceAll('>', '&gt;')
            .replaceAll('"', '&quot;')
            .replaceAll("'", '&#39;');
    }

    // --- ç¯å¢ƒé€»è¾‘ ---
    let currentSeason = 'spring';
    let isNight = false;
    let lastNightFlag = null;
    let lastThemeMinute = null;
    let themePreview = null;
    let themePreviewIndex = -1;
    let lunarCache = { key: null, info: null };

    let weatherState = {
        type: 'clear',
        icon: 'â˜€ï¸',
        label: 'æ™´',
        wind: 0,
        temp: null,
        updatedAt: 0
    };

    let lastWeatherType = 'clear';

    function updateEnvironment() {
        const now = new Date();
        const hour = now.getHours();
        const minute = now.getMinutes();
        const month = now.getMonth() + 1; // 1-12
        const body = document.body;
        
        // 1. å­£èŠ‚åˆ¤æ–­
        let seasonName = 'æ˜¥';
        if (month >= 3 && month <= 5) { currentSeason = 'spring'; seasonName = 'æ˜¥'; }
        else if (month >= 6 && month <= 8) { currentSeason = 'summer'; seasonName = 'å¤'; }
        else if (month >= 9 && month <= 11) { currentSeason = 'autumn'; seasonName = 'ç§‹'; }
        else { currentSeason = 'winter'; seasonName = 'å†¬'; }
        
        body.classList.remove('season-spring', 'season-summer', 'season-autumn', 'season-winter');
        body.classList.remove('time-night');
        body.classList.add(`season-${currentSeason}`);

        // 2. æ˜¼å¤œåˆ¤æ–­ (6-18ç‚¹ä¸ºç™½å¤©)
        let timeIcon = 'â˜€ï¸';
        if (hour < 6 || hour >= 18) {
            isNight = true;
            timeIcon = 'ğŸŒ™';
            body.classList.add('time-night');
        } else {
            isNight = false;
        }

        const themeHour = themePreview ? themePreview.hour : hour;
        const themeMinute = themePreview ? themePreview.minute : minute;

        if (themePreview) {
            applyDynamicTheme(themeHour, themeMinute, currentSeason);
        } else if (lastThemeMinute === null || lastThemeMinute !== minute) {
            lastThemeMinute = minute;
            applyDynamicTheme(themeHour, themeMinute, currentSeason);
        }

        if (lastNightFlag === null) lastNightFlag = isNight;
        if (lastNightFlag !== isNight) {
            lastNightFlag = isNight;
            if (state && Array.isArray(state.farm)) {
                for (let i = 0; i < state.farm.length; i++) renderFarmCell(i);
            }
        }

        // 3. UI æ›´æ–°
        const timeStr = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
        const dateStr = `${month}æœˆ${now.getDate()}æ—¥`;
        const w = weatherState || { icon: 'â˜€ï¸', label: 'æ™´' };
        const wStr = `${w.icon} ${w.label}`;
        const previewStr = themePreview ? `<span class="badge" style="margin-left:6px; background:rgba(253,203,110,0.18); border-color:rgba(211,84,0,0.16); color:rgba(211,84,0,0.9);">é¢„è§ˆ ${String(themeHour).padStart(2,'0')}:${String(themeMinute).padStart(2,'0')}</span>` : '';
        const lunar = getLunarInfo(now);
        const lunarLine = `<br><span class="muted">å†œå†ï¼š${escapeHtml(lunar.supported ? lunar.display : 'å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ')}ï½œæ—ºç§ï¼š${escapeHtml(lunar.supported ? lunar.recommendText : 'æ— ')}</span>`;
        document.getElementById('time-display').innerHTML = 
            `${timeIcon} ${seasonName}å­£ | ${dateStr} ${timeStr}${previewStr}<br>å¤©æ°”ï¼š${wStr}${lunarLine}`;
    }

    function cycleThemePreview() {
        const list = [
            { hour: 6, minute: 0 },
            { hour: 9, minute: 0 },
            { hour: 12, minute: 0 },
            { hour: 16, minute: 30 },
            { hour: 18, minute: 30 },
            { hour: 20, minute: 0 },
            { hour: 0, minute: 0 }
        ];
        themePreviewIndex = (themePreviewIndex + 1) % (list.length + 1);
        if (themePreviewIndex === list.length) {
            themePreview = null;
            themePreviewIndex = -1;
            showToast('å·²é€€å‡ºä¸»é¢˜é¢„è§ˆ', 'success');
        } else {
            themePreview = list[themePreviewIndex];
            showToast(`ä¸»é¢˜é¢„è§ˆï¼š${String(themePreview.hour).padStart(2,'0')}:${String(themePreview.minute).padStart(2,'0')}`, 'success');
        }
        updateEnvironment();
    }

    const LUNAR_MONTH_NAMES = ['','æ­£æœˆ','äºŒæœˆ','ä¸‰æœˆ','å››æœˆ','äº”æœˆ','å…­æœˆ','ä¸ƒæœˆ','å…«æœˆ','ä¹æœˆ','åæœˆ','å†¬æœˆ','è…Šæœˆ'];
    const LUNAR_DAY_NAMES = [
        '',
        'åˆä¸€','åˆäºŒ','åˆä¸‰','åˆå››','åˆäº”','åˆå…­','åˆä¸ƒ','åˆå…«','åˆä¹','åˆå',
        'åä¸€','åäºŒ','åä¸‰','åå››','åäº”','åå…­','åä¸ƒ','åå…«','åä¹','äºŒå',
        'å»¿ä¸€','å»¿äºŒ','å»¿ä¸‰','å»¿å››','å»¿äº”','å»¿å…­','å»¿ä¸ƒ','å»¿å…«','å»¿ä¹','ä¸‰å'
    ];

    const LUNAR_BONUS_BY_MONTH = {
        1: { crops: ['wheat','strawberry','cabbage'], sellMul: 1.20, yieldExtra: 1 },
        2: { crops: ['bamboo','radish','lettuce'], sellMul: 1.20, yieldExtra: 1 },
        3: { crops: ['tea_bush','rose','pea'], sellMul: 1.18, yieldExtra: 1 },
        4: { crops: ['garlic','onion','kale'], sellMul: 1.18, yieldExtra: 1 },
        5: { crops: ['rice','mint','basil'], sellMul: 1.18, yieldExtra: 1 },
        6: { crops: ['watermelon','melon','cucumber'], sellMul: 1.20, yieldExtra: 1 },
        7: { crops: ['corn','tomato','pepper'], sellMul: 1.18, yieldExtra: 1 },
        8: { crops: ['grape','apple','cranberry'], sellMul: 1.20, yieldExtra: 1 },
        9: { crops: ['pumpkin','sweet_potato','yam'], sellMul: 1.18, yieldExtra: 1 },
        10: { crops: ['mushroom','bok_choy','rye'], sellMul: 1.18, yieldExtra: 1 },
        11: { crops: ['potato','winter_root','spinach'], sellMul: 1.18, yieldExtra: 1 },
        12: { crops: ['crystal_fruit','cactus','ancient_fruit'], sellMul: 1.25, yieldExtra: 1 }
    };

    function getLunarInfo(date = new Date()) {
        const key = date.toDateString();
        if (lunarCache.key === key && lunarCache.info) return lunarCache.info;

        let supported = false;
        let lunarMonth = 0;
        let lunarDay = 0;
        let isLeapMonth = false;
        let display = '';

        try {
            const fmt = new Intl.DateTimeFormat('zh-CN-u-ca-chinese', { year: 'numeric', month: 'numeric', day: 'numeric' });
            const parts = fmt.formatToParts(date);
            const monthRaw = (parts.find(p => p.type === 'month')?.value) || '';
            const dayRaw = (parts.find(p => p.type === 'day')?.value) || '';
            const m = parseInt(String(monthRaw).replace(/[^\d]/g, ''), 10);
            const d = parseInt(String(dayRaw).replace(/[^\d]/g, ''), 10);
            if (Number.isFinite(m) && Number.isFinite(d)) {
                supported = true;
                lunarMonth = m;
                lunarDay = d;
                isLeapMonth = /é—°/.test(String(monthRaw));
                const monthName = LUNAR_MONTH_NAMES[lunarMonth] || `${lunarMonth}æœˆ`;
                const dayName = LUNAR_DAY_NAMES[lunarDay] || `${lunarDay}`;
                display = `${isLeapMonth ? 'é—°' : ''}${monthName}${dayName}`;
            }
        } catch {
            supported = false;
        }

        const monthBonus = supported ? (LUNAR_BONUS_BY_MONTH[lunarMonth] || null) : null;
        const recIds = monthBonus ? monthBonus.crops : [];
        const recNames = recIds
            .filter(id => CROPS[id])
            .slice(0, 3)
            .map(id => `${CROPS[id].emoji}${CROPS[id].name}`);
        const recommendText = monthBonus ? `${recNames.join(' ')}ï¼ˆæ”¶è·+${monthBonus.yieldExtra}ï½œå–ä»·Ã—${monthBonus.sellMul}ï¼‰` : 'æ— ';

        const info = { supported, lunarMonth, lunarDay, isLeapMonth, display, monthBonus, recommendText };
        lunarCache = { key, info };
        return info;
    }

    function getLunarCropBonus(cropId) {
        const lunar = getLunarInfo(new Date());
        if (!lunar.supported || !lunar.monthBonus) return { active: false, yieldExtra: 0, sellMul: 1 };
        const active = lunar.monthBonus.crops.includes(cropId);
        return {
            active,
            yieldExtra: active ? (lunar.monthBonus.yieldExtra || 0) : 0,
            sellMul: active ? (lunar.monthBonus.sellMul || 1) : 1
        };
    }

    function clamp01(x) {
        if (x < 0) return 0;
        if (x > 1) return 1;
        return x;
    }

    function mix(a, b, t) {
        return a + (b - a) * t;
    }

    function mixRgb(a, b, t) {
        return {
            r: Math.round(mix(a.r, b.r, t)),
            g: Math.round(mix(a.g, b.g, t)),
            b: Math.round(mix(a.b, b.b, t))
        };
    }

    function rgbCss(c) {
        return `rgb(${c.r}, ${c.g}, ${c.b})`;
    }

    function rgbaCss(c, a) {
        const alpha = Math.round(clamp01(a) * 1000) / 1000;
        return `rgba(${c.r}, ${c.g}, ${c.b}, ${alpha})`;
    }

    function applyDynamicTheme(hour, minute, season) {
        const h = (hour || 0) + (minute || 0) / 60;
        const sun = Math.cos(((h - 12) / 24) * Math.PI * 2);
        let nightT = clamp01((1 - sun) / 2);
        nightT = Math.pow(nightT, 0.85);

        const seasonDay = {
            spring: { a: { r: 132, g: 250, b: 176 }, b: { r: 143, g: 211, b: 244 }, c: { r: 214, g: 252, b: 255 } },
            summer: { a: { r: 255, g: 220, b: 120 }, b: { r: 116, g: 185, b: 255 }, c: { r: 120, g: 255, b: 214 } },
            autumn: { a: { r: 255, g: 159, b: 67 }, b: { r: 253, g: 203, b: 110 }, c: { r: 255, g: 118, b: 117 } },
            winter: { a: { r: 162, g: 155, b: 254 }, b: { r: 116, g: 185, b: 255 }, c: { r: 223, g: 230, b: 233 } }
        };
        const base = seasonDay[season] || seasonDay.spring;

        const nightBase = { a: { r: 15, g: 32, b: 39 }, b: { r: 32, g: 58, b: 67 }, c: { r: 44, g: 83, b: 100 } };
        const tint = base.b;
        const nightA = mixRgb(nightBase.a, tint, 0.10);
        const nightB = mixRgb(nightBase.b, tint, 0.10);
        const nightC = mixRgb(nightBase.c, tint, 0.10);

        const bgA = mixRgb(base.a, nightA, nightT);
        const bgB = mixRgb(base.b, nightB, nightT);
        const bgC = mixRgb(base.c, nightC, nightT);

        const textDay = { main: { r: 45, g: 52, b: 54 }, muted: { r: 99, g: 110, b: 114 } };
        const textNight = { main: { r: 245, g: 246, b: 250 }, muted: { r: 245, g: 246, b: 250 } };
        const textMain = mixRgb(textDay.main, textNight.main, nightT);
        const textMuted = mixRgb(textDay.muted, textNight.muted, nightT);
        const mutedAlpha = mix(1, 0.72, nightT);

        const glassDay = { r: 255, g: 255, b: 255, a: 0.65 };
        const glassNight = { r: 18, g: 26, b: 42, a: 0.70 };
        const glassRgb = mixRgb({ r: glassDay.r, g: glassDay.g, b: glassDay.b }, { r: glassNight.r, g: glassNight.g, b: glassNight.b }, nightT);
        const glassA = mix(glassDay.a, glassNight.a, nightT);

        const borderDay = { r: 255, g: 255, b: 255, a: 0.55 };
        const borderNight = { r: 255, g: 255, b: 255, a: 0.12 };
        const borderRgb = mixRgb({ r: borderDay.r, g: borderDay.g, b: borderDay.b }, { r: borderNight.r, g: borderNight.g, b: borderNight.b }, nightT);
        const borderA = mix(borderDay.a, borderNight.a, nightT);

        const cardDay = { r: 255, g: 255, b: 255, a: 0.82 };
        const cardNight = { r: 30, g: 40, b: 60, a: 0.74 };
        const cardRgb = mixRgb({ r: cardDay.r, g: cardDay.g, b: cardDay.b }, { r: cardNight.r, g: cardNight.g, b: cardNight.b }, nightT);
        const cardA = mix(cardDay.a, cardNight.a, nightT);

        const hoverDay = { r: 255, g: 255, b: 255, a: 0.98 };
        const hoverNight = { r: 40, g: 55, b: 85, a: 0.80 };
        const hoverRgb = mixRgb({ r: hoverDay.r, g: hoverDay.g, b: hoverDay.b }, { r: hoverNight.r, g: hoverNight.g, b: hoverNight.b }, nightT);
        const hoverA = mix(hoverDay.a, hoverNight.a, nightT);

        const tabBgDay = { r: 255, g: 255, b: 255, a: 0.92 };
        const tabBgNight = { r: 255, g: 255, b: 255, a: 0.14 };
        const tabRgb = mixRgb({ r: tabBgDay.r, g: tabBgDay.g, b: tabBgDay.b }, { r: tabBgNight.r, g: tabBgNight.g, b: tabBgNight.b }, nightT);
        const tabA = mix(tabBgDay.a, tabBgNight.a, nightT);

        const dividerA = mix(0.08, 0.16, nightT);
        const chipBorderDay = { r: 255, g: 234, b: 167 };
        const chipBorderNight = { r: 255, g: 255, b: 255 };
        const chipBorder = mixRgb(chipBorderDay, chipBorderNight, nightT);
        const chipBorderAlpha = mix(1, 0.14, nightT);

        const btnDisabledDay = { r: 178, g: 190, b: 195 };
        const btnDisabledNight = { r: 99, g: 110, b: 114 };
        const btnDisabled = mixRgb(btnDisabledDay, btnDisabledNight, nightT);
        const btnDisabledAlpha = mix(1, 0.58, nightT);

        const body = document.body;
        body.style.setProperty('--bg-a', rgbCss(bgA));
        body.style.setProperty('--bg-b', rgbCss(bgB));
        body.style.setProperty('--bg-c', rgbCss(bgC));

        body.style.setProperty('--text-main', rgbCss(textMain));
        body.style.setProperty('--text-muted', rgbaCss(textMuted, mutedAlpha));

        body.style.setProperty('--glass-bg', rgbaCss(glassRgb, glassA));
        body.style.setProperty('--glass-border', rgbaCss(borderRgb, borderA));

        body.style.setProperty('--card-bg', rgbaCss(cardRgb, cardA));
        body.style.setProperty('--card-hover', rgbaCss(hoverRgb, hoverA));

        body.style.setProperty('--tab-active-bg', rgbaCss(tabRgb, tabA));
        body.style.setProperty('--divider', `rgba(255,255,255,${Math.round(dividerA * 1000) / 1000})`);
        if (nightT < 0.5) body.style.setProperty('--divider', `rgba(0,0,0,${Math.round(mix(0.08, 0.05, nightT * 2) * 1000) / 1000})`);

        body.style.setProperty('--chip-border', rgbaCss(chipBorder, chipBorderAlpha));
        body.style.setProperty('--chip-bg', `linear-gradient(to right, ${rgbaCss(mixRgb({ r: 255, g: 245, b: 230 }, { r: 28, g: 38, b: 60 }, nightT), mix(1, 0.70, nightT))}, ${rgbaCss(mixRgb({ r: 255, g: 255, b: 255 }, { r: 18, g: 26, b: 42 }, nightT), mix(1, 0.70, nightT))})`);

        body.style.setProperty('--btn-buy-disabled-bg', rgbaCss(btnDisabled, btnDisabledAlpha));
        body.style.setProperty('--btn-buy-shadow', rgbaCss(mixRgb({ r: 0, g: 140, b: 112 }, { r: 0, g: 0, b: 0 }, nightT), mix(1, 0.35, nightT)));
    }

    let weatherCoords = null;

    function initWeather() {
        refreshWeather(true);
        setInterval(() => {
            try { refreshWeather(false); } catch {}
        }, 10 * 60 * 1000);
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                try { refreshWeather(false); } catch {}
            }
        });
    }

    async function refreshWeather(force = false) {
        const now = Date.now();
        if (!force && weatherState.updatedAt && now - weatherState.updatedAt < 3 * 60 * 1000) return;

        try {
            if (!weatherCoords) {
                weatherCoords = await new Promise((resolve, reject) => {
                    if (!navigator.geolocation) return reject(new Error('no_geolocation'));
                    navigator.geolocation.getCurrentPosition(
                        (pos) => resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude }),
                        (err) => reject(err),
                        { enableHighAccuracy: false, timeout: 5000, maximumAge: 15 * 60 * 1000 }
                    );
                });
            }

            const url = `https://api.open-meteo.com/v1/forecast?latitude=${encodeURIComponent(weatherCoords.lat)}&longitude=${encodeURIComponent(weatherCoords.lon)}&current=temperature_2m,precipitation,rain,snowfall,weather_code,wind_speed_10m&timezone=auto`;
            const res = await fetch(url, { cache: 'no-store' });
            if (!res.ok) throw new Error('weather_fetch_failed');
            const data = await res.json();
            const cur = data && data.current ? data.current : null;
            if (!cur) throw new Error('weather_no_current');

            const wind = Number(cur.wind_speed_10m || 0) || 0;
            const precipitation = Number(cur.precipitation || 0) || 0;
            const rain = Number(cur.rain || 0) || 0;
            const snowfall = Number(cur.snowfall || 0) || 0;
            const code = Number(cur.weather_code || 0) || 0;
            const temp = typeof cur.temperature_2m === 'number' ? cur.temperature_2m : null;

            const wx = mapWeather({ wind, precipitation, rain, snowfall, code });
            setWeatherState({ ...wx, wind, temp, updatedAt: now });
        } catch {
            const wx = fallbackWeather();
            setWeatherState({ ...wx, updatedAt: now });
        }
    }

    function mapWeather({ wind, precipitation, rain, snowfall, code }) {
        const isSnow = snowfall > 0 || (code >= 71 && code <= 77) || code === 85 || code === 86;
        const isRain = rain > 0 || precipitation > 0 || (code >= 51 && code <= 67) || (code >= 80 && code <= 82) || (code >= 95 && code <= 99);
        const isCloudy = !isSnow && !isRain && (code === 1 || code === 2 || code === 3);
        const isWind = !isSnow && !isRain && wind >= 10;

        if (isSnow) return { type: 'snow', icon: 'ğŸŒ¨ï¸', label: 'ä¸‹é›ª' };
        if (isRain) return { type: 'rain', icon: 'ğŸŒ§ï¸', label: 'ä¸‹é›¨' };
        if (isWind) return { type: 'wind', icon: 'ğŸŒ¬ï¸', label: 'å¤§é£' };
        if (isCloudy) return { type: 'cloudy', icon: 'â˜ï¸', label: 'å¤šäº‘' };
        return { type: 'clear', icon: 'â˜€ï¸', label: 'æ™´æœ—' };
    }

    function fallbackWeather() {
        const now = new Date();
        const hour = now.getHours();
        const seed = Number(`${now.getFullYear()}${now.getMonth() + 1}${now.getDate()}${hour}`);
        const x = Math.abs(Math.sin(seed)) % 1;
        const winter = currentSeason === 'winter';
        const summer = currentSeason === 'summer';
        if (winter && x > 0.78) return { type: 'snow', icon: 'ğŸŒ¨ï¸', label: 'ä¸‹é›ª' };
        if (!winter && x > 0.82) return { type: 'rain', icon: 'ğŸŒ§ï¸', label: 'ä¸‹é›¨' };
        if (summer && x > 0.66) return { type: 'wind', icon: 'ğŸŒ¬ï¸', label: 'å¤§é£' };
        if (x > 0.45) return { type: 'cloudy', icon: 'â˜ï¸', label: 'å¤šäº‘' };
        return { type: 'clear', icon: 'â˜€ï¸', label: 'æ™´æœ—' };
    }

    function setWeatherState(next) {
        weatherState = { ...weatherState, ...next };

        const body = document.body;
        body.classList.remove('weather-rain', 'weather-snow', 'weather-wind');
        if (weatherState.type === 'rain') body.classList.add('weather-rain');
        if (weatherState.type === 'snow') body.classList.add('weather-snow');
        if (weatherState.type === 'wind') body.classList.add('weather-wind');

        if (weatherState.type !== lastWeatherType) {
            if (weatherState.type === 'rain') {
                applyRainWatering();
                showToast('ä¸‹é›¨äº†ï¼šåœŸåœ°è¢«æµ‡æ¹¿äº†', 'success');
            } else if (weatherState.type === 'snow') {
                showToast('ä¸‹é›ªäº†ï¼šä½œç‰©ç”Ÿé•¿å˜æ…¢');
            } else if (weatherState.type === 'wind') {
                showToast('åˆ®é£äº†ï¼šä½œç‰©ç”Ÿé•¿ç•¥æ…¢');
            }
            lastWeatherType = weatherState.type;
        }

        updateEnvironment();
    }

    function applyRainWatering() {
        const now = Date.now();
        const until = now + getWaterDurationMs();
        for (let i = 0; i < state.farm.length; i++) {
            const c = state.farm[i];
            if (!c) continue;
            if (c.locked) continue;
            if (c.type !== 'tilled') continue;
            c.waterUntil = Math.max(c.waterUntil || 0, until);
        }
        updateFarmVisuals();
    }

    // --- æ¸¸æˆå¾ªç¯ (æ ¸å¿ƒé€»è¾‘) ---
    function gameLoop() {
        const now = Date.now();
        let needsUpdate = false;

        if (weatherState && weatherState.type === 'rain') {
            for (let i = 0; i < state.farm.length; i++) {
                const c = state.farm[i];
                if (!c) continue;
                if (c.locked) continue;
                if (c.type !== 'tilled') continue;
                c.waterUntil = Math.max(c.waterUntil || 0, now + 5000);
            }
        }

        state.farm.forEach((cell, idx) => {
            if (cell.locked) return;
            if (cell.cropId) {
                const crop = CROPS[cell.cropId];
                const isWatered = cell.waterUntil > now;
                
                if (!cell.progress) cell.progress = 0;
                
                if (cell.progress < 100) {
                    let increment = (100 / crop.time); // æ¯ç§’å¢åŠ ç™¾åˆ†æ¯”
                    if (isWatered) increment *= 2; // æµ‡æ°´åŒå€é€Ÿ
                    if (cell.fertilized) increment *= 1.5;
                    if (crop.trait && crop.trait.type === 'speed' && typeof crop.trait.val === 'number') increment *= crop.trait.val;
                    
                    // ç¯å¢ƒåŠ æˆ
                    if (crop.growth_bonus) {
                        if (crop.growth_bonus === 'night' && isNight) increment *= 2;
                        if (crop.growth_bonus === 'day' && !isNight) increment *= 2;
                    }

                    if (isNight && isCellLit(idx)) increment *= 1.35;

                    increment *= getWeatherGrowthMultiplier();

                    cell.progress += increment;
                    
                    // ç¡®ä¿ä¸è¶…è¿‡100
                    if (cell.progress >= 100) {
                        cell.progress = 100;
                        showToast(`${crop.name} æˆç†Ÿäº†ï¼`, "success");
                    }
                    needsUpdate = true;
                }
            }
        });

        robotHarvestTick();
        buildingTick();
        breweryTick(now);
        ordersTick(now);

        weedGrowTick(now);

        // å³ä½¿æ²¡æœ‰è¿›åº¦æ›´æ–°ï¼Œä¹Ÿå¯èƒ½éœ€è¦æ›´æ–°å€’è®¡æ—¶æ˜¾ç¤º
        updateFarmVisuals();
    }

    function getWeatherGrowthMultiplier() {
        if (!weatherState) return 1;
        if (weatherState.type === 'snow') return 0.75;
        if (weatherState.type === 'wind') return 0.9;
        return 1;
    }

    function getWeedGrowMs() {
        const n = getBuildingCount('fence');
        const slow = Math.min(0.5, n * 0.08);
        return Math.round(WEED.growMs * (1 + slow));
    }

    function weedGrowTick(now) {
        let grown = 0;
        const growMs = getWeedGrowMs();
        for (let i = 0; i < state.farm.length; i++) {
            const cell = state.farm[i];
            if (!cell) continue;
            if (cell.locked) continue;
            if (cell.cropId) continue;
            if (cell.weed) continue;
            const t0 = typeof cell.emptySince === 'number' ? cell.emptySince : now;
            if (now - t0 >= growMs) {
                cell.weed = true;
                grown++;
                renderFarmCell(i);
            }
        }
        if (grown > 0) showToast(`æ‚è‰é•¿å‡ºæ¥äº†ï¼š${grown}å¤„`);
    }

    function robotHarvestTick(silent = true, render = true) {
        if (!state.robot || !state.robot.owned) return 0;
        if ((state.robot.energy || 0) <= 0) return 0;

        let harvested = 0;
        state.farm.forEach((cell, idx) => {
            if ((state.robot.energy || 0) <= 0) return;
            if (cell.locked) return;
            if (cell.cropId && (cell.progress || 0) >= 100) {
                handleHarvest(cell, idx);
                state.robot.energy = Math.max(0, (state.robot.energy || 0) - 1);
                harvested++;
                if (render) renderFarmCell(idx);
            }
        });

        if (harvested > 0) {
            if (render) {
                renderInventory();
                renderShop();
            }
            if (!silent) showToast(`æœºå™¨äººæ”¶å‰² ${harvested} ä¸ªä½œç‰©`, 'success');
        }

        return harvested;
    }

    // --- äº¤äº’é€»è¾‘ ---
    function onCellClick(idx) {
        const cell = state.farm[idx];
        const now = Date.now();

        if (cell.locked) {
            if (state.tool !== 'hand') {
                showToast('è¿™å—åœ°è¿˜æ²¡è§£é”ï¼Œåˆ‡åˆ°ğŸ‘†ç‚¹å‡»è§£é”');
                return;
            }
            tryUnlockLand(idx);
            return;
        }

        if (state.buildings && state.buildings.placeMode === 'lamp') {
            if (state.tool !== 'hand') {
                showToast('æ‘†æ”¾æ¨¡å¼ä¸‹è¯·ä½¿ç”¨ğŸ‘†');
                return;
            }
            toggleLampAtCell(idx);
            return;
        }

        // åˆå§‹æ‚è‰ï¼šéœ€å…ˆæ¸…ç†
        if (!cell.cropId && cell.weed) {
            if (state.tool === 'scythe') {
                cell.weed = false;
                cell.emptySince = now;
                state.inventory.crops['weed'] = (state.inventory.crops['weed'] || 0) + 1;
                showToast("æ¸…ç†æ‚è‰ +1ğŸŒ¿", "success");
                renderInventory();
                renderFarmCell(idx);
                playSound('harvest');
                return;
            }
            if (state.tool === 'basket') {
                let cleared = 0;
                state.farm.forEach((c, i2) => {
                    if (!c.cropId && c.weed) {
                        c.weed = false;
                        c.emptySince = now;
                        state.inventory.crops['weed'] = (state.inventory.crops['weed'] || 0) + 1;
                        cleared++;
                    }
                });
                if (cleared > 0) {
                    showToast(`æ¸…ç† ${cleared} å¤„æ‚è‰`, "success");
                    renderInventory();
                    state.farm.forEach((_, i3) => renderFarmCell(i3));
                    playSound('harvest');
                }
                return;
            }
            if (state.tool === 'hand') {
                showToast("è¿™é‡Œæ˜¯æ‚è‰ï¼Œä½¿ç”¨âš”ï¸æ¸…ç†");
                return;
            }
            showToast("å…ˆç”¨âš”ï¸æ¸…ç†æ‚è‰");
            return;
        }

        // 1. é”„å¤´
        if (state.tool === 'hoe') {
            if (cell.type === 'wild') {
                cell.type = 'tilled';
                cell.emptySince = now;
                playSound('dig');
                renderFarmCell(idx);
            } else if (cell.cropId) {
                // é“²é™¤ä½œç‰©åŠŸèƒ½
                if(confirm(`ç¡®å®šè¦é“²é™¤ ${CROPS[cell.cropId].name} å—ï¼Ÿ`)) {
                    cell.cropId = null;
                    cell.progress = 0;
                    cell.waterUntil = 0;
                    cell.fertilized = false;
                    cell.harvestCount = 0;
                    cell.weed = false;
                    cell.emptySince = now;
                    renderFarmCell(idx);
                    playSound('dig');
                }
            }
        }
        // 2. æ’­ç§ (é€‰ä¸­ç§å­æ—¶è¦†ç›–å·¥å…·)
        else if (state.selectedSeed) {
            if (cell.type === 'tilled' && !cell.cropId) {
                const crop = CROPS[state.selectedSeed];
                // å­£èŠ‚æ£€æŸ¥
                if (crop.seasons && crop.seasons.length > 0 && !crop.seasons.includes(currentSeason)) {
                    showToast(`åªèƒ½åœ¨ ${crop.seasons.map(s=>{
                        return {'spring':'æ˜¥','summer':'å¤','autumn':'ç§‹','winter':'å†¬'}[s]
                    }).join('/')} ç§æ¤!`);
                    return;
                }

                if (state.inventory.seeds[state.selectedSeed] > 0) {
                    state.inventory.seeds[state.selectedSeed]--;
                    cell.cropId = state.selectedSeed;
                    cell.plantedAt = now;
                    cell.progress = 0;
                    cell.waterUntil = 0;
                    cell.weed = false;
                    cell.emptySince = 0;
                    
                    if (state.inventory.seeds[state.selectedSeed] === 0) {
                        state.selectedSeed = null;
                        state.tool = 'hand'; // ç§å­ç”¨å®Œåˆ‡å›æ‰‹
                    }
                    
                    renderInventory();
                    updateToolsUI();
                    renderFarmCell(idx);
                    playSound('plant');
                }
            } else if (cell.type === 'wild') {
                showToast("å…ˆå¼€å¦åœŸåœ°ï¼");
            }
        }
        // 3. æ°´å£¶
        else if (state.tool === 'water') {
            if (cell.type !== 'wild') {
                cell.waterUntil = now + getWaterDurationMs(); 
                renderFarmCell(idx);
                playSound('water');
            }
        }
        // 4. é•°åˆ€ (æ”¶è·)
        else if (state.tool === 'scythe') {
            if (cell.cropId && cell.progress >= 100) {
                const msg = handleHarvest(cell, idx);
                showToast(msg, "success");
                renderInventory();
                renderFarmCell(idx);
                playSound('harvest');
            }
        }
        // 5. æ–½è‚¥
        else if (state.tool === 'fertilizer') {
            if (cell.cropId && (cell.progress || 0) < 100 && !cell.fertilized) {
                if (state.inventory.fertilizer > 0) {
                    state.inventory.fertilizer--;
                    cell.fertilized = true;
                    showToast("æ–½è‚¥æˆåŠŸ", "success");
                    renderFarmCell(idx);
                    updateToolsUI();
                } else {
                    showToast("æ²¡æœ‰è‚¥æ–™äº†ï¼ç”¨æ‚è‰åˆ¶ä½œå§", "normal");
                }
            } else if (cell.fertilized) {
                showToast("å·²ç»æ–½è¿‡è‚¥äº†");
            }
        }
        // 6. æ”¶é›†ç¯®
        else if (state.tool === 'basket') {
            let harvested = 0;
            state.farm.forEach((c, i2) => {
                if (c.cropId && (c.progress || 0) >= 100) {
                    handleHarvest(c, i2);
                    harvested++;
                }
            });
            if (harvested > 0) {
                showToast(`æ”¶é›† ${harvested} ä¸ªä½œç‰©`, "success");
                renderInventory();
                state.farm.forEach((_, i3) => renderFarmCell(i3));
                playSound('harvest');
            }
        }
        // 7. é“²å­ (ç§»é™¤ä½œç‰©)
        else if (state.tool === 'shovel') {
            if (cell.cropId) {
                if(confirm(`ç¡®å®šè¦é“²é™¤ ${CROPS[cell.cropId].name} å—ï¼Ÿå°†è·å¾—æ‚è‰ã€‚`)) {
                    cell.cropId = null;
                    cell.progress = 0;
                    cell.waterUntil = 0;
                    cell.fertilized = false;
                    cell.harvestCount = 0;
                    cell.weed = false;
                    cell.emptySince = now;
                    state.inventory.crops['weed'] = (state.inventory.crops['weed'] || 0) + 1;
                    showToast("è·å¾— 1x æ‚è‰");
                    renderFarmCell(idx);
                    renderInventory();
                    playSound('dig');
                }
            } else {
                showToast("è¿™é‡Œæ²¡æœ‰ä½œç‰©");
            }
        }
        // 8. æ‰‹ (ç‚¹å‡»ä¿¡æ¯)
        else if (state.tool === 'hand') {
            if (cell.cropId) {
                const crop = CROPS[cell.cropId];
                let info = "";
                if (cell.progress >= 100) info = "å¯ä»¥æ”¶è·äº†ï¼";
                else info = `ç”Ÿé•¿ä¸­... (${Math.floor(cell.progress)}%)`;
                
                if (crop.trait && crop.trait.type === 'regrow') {
                    info += ` [æ”¶è·: ${cell.harvestCount || 0}/${crop.trait.max_harvest}]`;
                }
                showToast(`${crop.name}: ${info}`);
            }
        }
    }

    function tryUnlockLand(idx) {
        const cell = state.farm[idx];
        if (!cell || !cell.locked) return;
        const price = getLandUnlockPrice(idx);
        if (state.coins < price) {
            showToast(`é‡‘å¸ä¸è¶³ ğŸ’¸ï¼ˆéœ€è¦ ${price} é‡‘ï¼‰`);
            return;
        }
        const ok = confirm(`è§£é”è¿™å—åœŸåœ°éœ€è¦ ${price} é‡‘ï¼Œç¡®å®šè§£é”å—ï¼Ÿ`);
        if (!ok) return;

        state.coins -= price;
        cell.locked = false;
        cell.type = 'wild';
        cell.cropId = null;
        cell.progress = 0;
        cell.waterUntil = 0;
        cell.fertilized = false;
        cell.harvestCount = 0;
        cell.weed = true;
        cell.emptySince = Date.now();

        updateHeader();
        renderFarmCell(idx);
        renderInventory();
        playSound('buy');
        showToast('è§£é”æˆåŠŸ âœ…', 'success');
    }

    function handleHarvest(cell, idx) {
        const crop = CROPS[cell.cropId];
        state.inventory.crops[cell.cropId] = (state.inventory.crops[cell.cropId] || 0) + 1;
        
        let msg = `æ”¶è· ${crop.name}`;

        const lunarBonus = getLunarCropBonus(cell.cropId);
        if (lunarBonus.active && lunarBonus.yieldExtra > 0) {
            state.inventory.crops[cell.cropId] += lunarBonus.yieldExtra;
            msg += ` (å†œå†æ—º +${lunarBonus.yieldExtra})`;
        }

        // ç‰¹æ€§ï¼šé¢å¤–æ”¶è· (bonus)
        if (crop.trait && crop.trait.type === 'bonus') {
            if (Math.random() < crop.trait.val) {
                state.inventory.crops[cell.cropId]++;
                msg += " (åŒå€!âœ¨)";
            }
        } else if (Math.random() > 0.9) {
             // é»˜è®¤å¾®å°æ¦‚ç‡åŒå€
             state.inventory.crops[cell.cropId]++;
             msg += " (å¥½è¿!âœ¨)";
        }
        
        // ç‰¹æ€§ï¼šç§å­æ‰è½ (seed_drop)
        if (crop.seed_drop) {
            if (Math.random() < crop.seed_drop.chance) {
                const seedCount = Math.floor(Math.random() * (crop.seed_drop.max - crop.seed_drop.min + 1)) + crop.seed_drop.min;
                if (seedCount > 0) {
                    state.inventory.seeds[cell.cropId] = (state.inventory.seeds[cell.cropId] || 0) + seedCount;
                    msg += ` +${seedCount}ç§å­`;
                }
            }
        }
        
        // ç‰¹æ€§ï¼šå†ç”Ÿ (regrow)
        if (crop.trait && crop.trait.type === 'regrow') {
            cell.harvestCount = (cell.harvestCount || 0) + 1;
            if (cell.harvestCount >= crop.trait.max_harvest) {
                cell.cropId = null;
                cell.progress = 0;
                cell.waterUntil = 0;
                cell.fertilized = false;
                cell.harvestCount = 0;
                cell.weed = false;
                cell.emptySince = Date.now();
                msg += " (æ¯èäº†)";
            } else {
                cell.progress = crop.trait.val; // å›é€€åˆ°æŒ‡å®šè¿›åº¦
                cell.waterUntil = 0; // éœ€é‡æ–°æµ‡æ°´
                cell.weed = false;
                cell.emptySince = 0;
                msg += ` (å†ç”Ÿ ${cell.harvestCount}/${crop.trait.max_harvest})`;
            }
        } else {
            cell.cropId = null;
            cell.progress = 0;
            cell.waterUntil = 0;
            cell.fertilized = false;
            cell.harvestCount = 0;
            cell.weed = false;
            cell.emptySince = Date.now();
        }
        return msg;
    }

    function buySeed(id) {
        const crop = CROPS[id];
        if (state.coins >= crop.price) {
            state.coins -= crop.price;
            state.inventory.seeds[id] = (state.inventory.seeds[id] || 0) + 1;
            updateHeader();
            renderInventory();
            playSound('buy');
        } else {
            showToast("é‡‘å¸ä¸è¶³ ğŸ’¸");
        }
    }

    function buyBattery() {
        if (state.coins < SHOP.batteryPrice) {
            showToast('é‡‘å¸ä¸è¶³ ğŸ’¸');
            return;
        }
        state.coins -= SHOP.batteryPrice;
        state.inventory.batteries = (state.inventory.batteries || 0) + 1;
        updateHeader();
        renderInventory();
        renderShop();
        playSound('buy');
    }

    function buyRobot() {
        if (state.robot.owned) {
            showToast('ä½ å·²ç»æ‹¥æœ‰æœºå™¨äººäº†');
            return;
        }
        if (state.coins < SHOP.robotPrice) {
            showToast('é‡‘å¸ä¸è¶³ ğŸ’¸');
            return;
        }
        state.coins -= SHOP.robotPrice;
        state.robot.owned = true;
        state.robot.maxEnergy = SHOP.robotMaxEnergy;
        state.robot.energy = Math.min(state.robot.maxEnergy, Math.max(state.robot.energy || 0, Math.ceil(state.robot.maxEnergy * 0.5)));
        updateHeader();
        renderInventory();
        renderShop();
        showToast('è·å¾— ğŸ¤– è‡ªåŠ¨æ”¶å‰²æœºå™¨äºº', 'success');
        playSound('buy');
    }

    function buyRecipeUnlock(index) {
        const r = RECIPES[index];
        if (!r || !r.unlockPrice) return;
        if (r.unlocked) {
            showToast('è¯¥é£Ÿè°±å·²è§£é”');
            return;
        }
        if (state.coins < r.unlockPrice) {
            showToast('é‡‘å¸ä¸è¶³ ğŸ’¸');
            return;
        }
        state.coins -= r.unlockPrice;
        r.unlocked = true;
        updateHeader();
        renderKitchen();
        renderShop();
        showToast(`è§£é”é£Ÿè°±ï¼š${r.name}`, 'success');
        playSound('buy');
    }

    function useBattery() {
        if (!state.robot.owned) {
            showToast('è¿˜æ²¡æœ‰æœºå™¨äºº');
            return;
        }
        const n = state.inventory.batteries || 0;
        if (n <= 0) {
            showToast('æ²¡æœ‰ç”µæ± äº†');
            return;
        }
        if ((state.robot.energy || 0) >= state.robot.maxEnergy) {
            showToast('ç”µé‡å·²æ»¡');
            return;
        }
        state.inventory.batteries = n - 1;
        state.robot.energy = Math.min(state.robot.maxEnergy, (state.robot.energy || 0) + SHOP.batteryCharge);
        renderInventory();
        renderShop();
        showToast(`å……ç”µ +${SHOP.batteryCharge}ğŸ”‹`, 'success');
        playSound('buy');
    }

    function getBuildingCount(id) {
        const v = state.buildings && state.buildings.owned ? state.buildings.owned[id] : 0;
        if (typeof v === 'number') return Math.max(0, Math.floor(v));
        return v ? 1 : 0;
    }

    function hasBuilding(id) {
        return getBuildingCount(id) > 0;
    }

    function getSellMultiplier() {
        let m = 1;
        if (hasBuilding('windmill')) m *= 1.10;
        return m;
    }

    function getWaterDurationMs() {
        return hasBuilding('well') ? 20000 : 10000;
    }

    function buyBuilding(id) {
        const b = BUILDINGS.find(x => x.id === id);
        if (!b) return;
        if (state.coins < b.price) {
            showToast('é‡‘å¸ä¸è¶³ ğŸ’¸');
            return;
        }
        state.coins -= b.price;
        if (b.kind === 'decor') {
            state.buildings.owned[id] = (getBuildingCount(id) || 0) + 1;
        } else {
            if (hasBuilding(id)) {
                showToast('å·²æ‹¥æœ‰è¯¥å»ºç­‘');
                state.coins += b.price;
                updateHeader();
                return;
            }
            state.buildings.owned[id] = true;
        }
        updateHeader();
        renderShop();
        renderBuildings();
        renderInventory();
        showToast(`${b.kind === 'decor' ? 'è´­ä¹°' : 'å»ºé€ '}å®Œæˆï¼š${b.emoji} ${b.name}`, 'success');
        playSound('buy');
    }

    function renderBuildings() {
        const el = document.getElementById('building-strip');
        if (!el) return;

        const owned = BUILDINGS.filter(b => hasBuilding(b.id));
        if (owned.length === 0) {
            el.innerHTML = '<div style="grid-column:1/-1; text-align:center; color:var(--text-muted); padding:6px 0;">å»å•†åº—è´­ä¹°å»ºç­‘</div>';
            return;
        }

        el.innerHTML = '';
        owned.forEach(b => {
            const count = getBuildingCount(b.id);
            const placing = state.buildings && state.buildings.placeMode === b.id;
            const placedCount = b.id === 'lamp' ? ((state.buildings && state.buildings.placed && Array.isArray(state.buildings.placed.lamp)) ? state.buildings.placed.lamp.length : 0) : 0;
            const div = document.createElement('div');
            div.className = 'building-tile' + (placing ? ' placing' : '');
            div.innerHTML = `
                <div class="building-emoji">${b.emoji}</div>
                <div class="building-name">${b.name}${b.kind === 'decor' && count > 1 ? ` Ã—${count}` : ''}</div>
                <div class="building-sub">${b.desc || ''}${b.id === 'lamp' && count > 0 ? `ï¼ˆå·²æ‘†æ”¾ ${placedCount}/${count}ï¼‰` : ''}</div>
                ${b.id === 'lamp' ? `<div class="building-actions"><button class="building-mini-btn" onclick="togglePlaceMode('lamp')">${placing ? 'å–æ¶ˆ' : 'æ‘†æ”¾'}</button></div>` : ''}
            `;
            el.appendChild(div);
        });
    }

    function sanitizeBuildingsPlaced(raw, lampCount) {
        const max = typeof lampCount === 'number' ? Math.max(0, Math.floor(lampCount)) : 0;
        const out = { lamp: [] };
        const src = raw && typeof raw === 'object' ? raw : {};
        const lamps = Array.isArray(src.lamp) ? src.lamp : [];
        const seen = new Set();
        for (const v of lamps) {
            const idx = typeof v === 'number' ? Math.floor(v) : NaN;
            if (!Number.isFinite(idx)) continue;
            if (idx < 0 || idx >= CONFIG.rows * CONFIG.cols) continue;
            if (seen.has(idx)) continue;
            seen.add(idx);
            out.lamp.push(idx);
            if (out.lamp.length >= max) break;
        }
        return out;
    }

    function togglePlaceMode(kind) {
        if (kind !== 'lamp') return;
        if (!hasBuilding('lamp')) {
            showToast('è¿˜æ²¡æœ‰ç¯ç¬¼ï¼Œå»å•†åº—è´­ä¹°');
            return;
        }
        if (!state.buildings) return;
        state.buildings.placeMode = state.buildings.placeMode === kind ? null : kind;
        renderBuildings();
        showToast(state.buildings.placeMode ? 'ç‚¹å‡»åœ°å—æ‘†æ”¾/æ’¤ä¸‹ğŸ®ï¼ˆä¸å åœ°ï¼‰' : 'å·²é€€å‡ºæ‘†æ”¾æ¨¡å¼');
    }

    function isCellLit(idx) {
        const placed = state.buildings && state.buildings.placed && Array.isArray(state.buildings.placed.lamp) ? state.buildings.placed.lamp : [];
        if (placed.length === 0) return false;
        const { r, c } = idxToRowCol(idx);
        const radius = 2;
        for (let i = 0; i < placed.length; i++) {
            const p = placed[i];
            const rc = idxToRowCol(p);
            const d = Math.abs(rc.r - r) + Math.abs(rc.c - c);
            if (d <= radius) return true;
        }
        return false;
    }

    function isLampPlacedAt(idx) {
        const placed = state.buildings && state.buildings.placed && Array.isArray(state.buildings.placed.lamp) ? state.buildings.placed.lamp : [];
        return placed.includes(idx);
    }

    function toggleLampAtCell(idx) {
        if (!state.buildings) return;
        if (!state.buildings.placed) state.buildings.placed = { lamp: [] };
        if (!Array.isArray(state.buildings.placed.lamp)) state.buildings.placed.lamp = [];
        const list = state.buildings.placed.lamp;
        const i = list.indexOf(idx);
        const max = getBuildingCount('lamp');
        if (i >= 0) {
            list.splice(i, 1);
            showToast('å·²æ’¤ä¸‹ğŸ®');
        } else {
            if (list.length >= max) {
                showToast(`ç¯ç¬¼ä¸å¤Ÿï¼ˆæœ€å¤šæ‘†æ”¾ ${max} ä¸ªï¼‰`);
                return;
            }
            list.push(idx);
            showToast('å·²æ‘†æ”¾ğŸ®');
        }
        for (let k = 0; k < state.farm.length; k++) renderFarmCell(k);
    }

    function buildingTick() {
        const now = Date.now();

        if (hasBuilding('compost')) {
            if (!state.buildings.compostNextAt || now >= state.buildings.compostNextAt) {
                state.buildings.compostNextAt = now + 25000;
                const weed = state.inventory.crops.weed || 0;
                if (weed >= 2) {
                    state.inventory.crops.weed = weed - 2;
                    state.inventory.fertilizer = (state.inventory.fertilizer || 0) + 1;
                    renderInventory();
                }
            }
        }

        if (hasBuilding('sprinkler')) {
            if (!state.buildings.sprinklerNextAt || now >= state.buildings.sprinklerNextAt) {
                state.buildings.sprinklerNextAt = now + 5000;
                let applied = 0;
                for (let i = 0; i < state.farm.length; i++) {
                    const cell = state.farm[i];
                    if (cell.cropId && (cell.progress || 0) < 100) {
                        if ((cell.waterUntil || 0) < now + 2500) {
                            cell.waterUntil = now + 2500;
                            renderFarmCell(i);
                            applied++;
                            if (applied >= 6) break;
                        }
                    }
                }
            }
        }
    }

    function sellCrop(id) {
        if (state.inventory.crops[id] > 0) {
            state.inventory.crops[id]--;
            const lunarBonus = getLunarCropBonus(id);
            state.coins += Math.round(CROPS[id].sell * getSellMultiplier() * (lunarBonus.active ? lunarBonus.sellMul : 1));
            updateHeader();
            renderInventory();
            playSound('coin');
        }
    }

    function sellAlcohol(drinkId) {
        const inv = state.inventory.alcohols || {};
        const n = inv[drinkId] || 0;
        if (n <= 0) return;
        const spec = getDrinkSpecByDrinkId(drinkId);
        if (!spec) return;
        inv[drinkId] = n - 1;
        state.coins += Math.round(spec.sell * getSellMultiplier());
        updateHeader();
        renderInventory();
        playSound('coin');
    }

    function craft(index) {
        const recipe = RECIPES[index];
        if (recipe && recipe.unlockPrice && !recipe.unlocked) {
            showToast('è¯¥é£Ÿè°±æœªè§£é”ï¼Œå»å•†åº—è´­ä¹°');
            return;
        }
        for (let ing in recipe.req) {
            if ((state.inventory.crops[ing] || 0) < recipe.req[ing]) {
                showToast("ææ–™ä¸è¶³");
                return;
            }
        }
        for (let ing in recipe.req) {
            state.inventory.crops[ing] -= recipe.req[ing];
        }
        state.inventory.foods[index] = (state.inventory.foods[index] || 0) + 1;
        renderInventory();
        showToast(`åˆ¶ä½œäº† ${recipe.name}ï¼Œå·²æ”¾å…¥èƒŒåŒ…`);
        playSound('buy');
    }
    function sellFood(index) {
        const count = state.inventory.foods[index] || 0;
        if (count > 0) {
            state.inventory.foods[index] = count - 1;
            state.coins += Math.round(RECIPES[index].price * getSellMultiplier());
            updateHeader();
            renderInventory();
            playSound('coin');
        }
    }

    // --- æ‰¹é‡å”®å–åŠŸèƒ½ ---
    const BatchSell = (function() {
        // ç§æœ‰çŠ¶æ€
        let state = {
            type: null, // 'crop', 'food', 'alcohol'
            id: null,
            name: '',
            emoji: '',
            price: 0,
            maxQty: 0,
            lunarBonus: null
        };
        let isOpen = false;

        // éªŒè¯æ•°é‡è¾“å…¥ï¼Œè¿”å›æœ‰æ•ˆæ•°å­—
        function parseValidQty(value, maxQty) {
            const parsed = parseInt(value, 10);
            if (isNaN(parsed) || parsed < 1) return 1;
            return Math.min(parsed, maxQty);
        }

        // è®¡ç®—å¸¦æ‰€æœ‰åŠ æˆçš„å•ä»·
        function calcSellPrice(basePrice, type, targetId) {
            let price = basePrice * getSellMultiplier();
            if (type === 'crop' && targetId) {
                const bonus = getLunarCropBonus(targetId);
                if (bonus && bonus.active) {
                    price *= bonus.sellMul;
                }
            }
            return Math.round(price);
        }

        // åˆ·æ–°å½“å‰æ•°é‡ï¼ˆè§£å†³å¹¶å‘é—®é¢˜ï¼‰
        function refreshCurrentQty() {
            if (state.type === 'crop') {
                state.maxQty = state.inventory?.crops?.[state.id] || 0;
            } else if (state.type === 'food') {
                state.maxQty = state.inventory?.foods?.[state.id] || 0;
            } else if (state.type === 'alcohol') {
                state.maxQty = (state.inventory?.alcohols || {})?.[state.id] || 0;
            }
            return state.maxQty;
        }

        function open(cropId) {
            if (!cropId || !CROPS[cropId]) { showToast('ç‰©å“ä¸å­˜åœ¨'); return; }
            const count = state.inventory?.crops?.[cropId] || 0;
            if (count <= 0) { showToast('æ²¡æœ‰å¯å”®å–çš„ä½œç‰©'); return; }

            state = {
                type: 'crop',
                id: cropId,
                name: CROPS[cropId].name,
                emoji: CROPS[cropId].emoji,
                price: calcSellPrice(CROPS[cropId].sell, 'crop', cropId),
                maxQty: count,
                lunarBonus: getLunarCropBonus(cropId)
            };
            showPanel();
        }

        function openFood(foodIndex) {
            if (foodIndex == null || !RECIPES[foodIndex]) { showToast('é£Ÿè°±ä¸å­˜åœ¨'); return; }
            const count = state.inventory?.foods?.[foodIndex] || 0;
            if (count <= 0) { showToast('æ²¡æœ‰å¯å”®å–çš„æ–™ç†'); return; }

            state = {
                type: 'food',
                id: foodIndex,
                name: RECIPES[foodIndex].name,
                emoji: RECIPES[foodIndex].emoji,
                price: calcSellPrice(RECIPES[foodIndex].price, 'food', null),
                maxQty: count,
                lunarBonus: null
            };
            showPanel();
        }

        function openAlcohol(drinkId) {
            const spec = getDrinkSpecByDrinkId(drinkId);
            if (!spec) { showToast('é…’å“ä¸å­˜åœ¨'); return; }
            const count = (state.inventory?.alcohols || {})?.[drinkId] || 0;
            if (count <= 0) { showToast('æ²¡æœ‰å¯å”®å–çš„é…’'); return; }

            state = {
                type: 'alcohol',
                id: drinkId,
                name: spec.name,
                emoji: spec.emoji,
                price: calcSellPrice(spec.sell, 'alcohol', null),
                maxQty: count,
                lunarBonus: null
            };
            showPanel();
        }

        function showPanel() {
            const overlay = document.getElementById('batch-sell-overlay');
            const content = document.getElementById('batch-sell-content');
            if (!overlay || !content) return;

            // ç¦ç”¨èƒŒæ™¯æ»šåŠ¨
            document.body.style.overflow = 'hidden';

            const bonusText = (state.lunarBonus && state.lunarBonus.active) ? `ï¼ˆå†œå†åŠ æˆÃ—${state.lunarBonus.sellMul}ï¼‰` : '';

            content.innerHTML = `
                <div class="batch-sell-item">
                    <div class="batch-sell-emoji">${state.emoji}</div>
                    <div class="batch-sell-info">
                        <div class="batch-sell-name">${state.name}</div>
                        <div class="batch-sell-price">å•ä»·: ${state.price}é‡‘${bonusText}</div>
                    </div>
                </div>
                <div class="batch-sell-qty-row">
                    <span class="batch-sell-qty-label">æ•°é‡</span>
                    <input type="number" id="batch-qty-input" class="batch-sell-qty-input"
                        min="1" max="${state.maxQty}" value="1"
                        onchange="BatchSell.updateTotal()" oninput="BatchSell.updateTotal()">
                    <div class="batch-sell-qty-btns">
                        <button class="batch-sell-qty-btn" onclick="BatchSell.adjust(-1)">-</button>
                        <button class="batch-sell-qty-btn all" onclick="BatchSell.setMax()">å…¨éƒ¨</button>
                        <button class="batch-sell-qty-btn" onclick="BatchSell.adjust(1)">+</button>
                    </div>
                </div>
                <div class="batch-sell-total">
                    <div class="batch-sell-total-label">é¢„è®¡è·å¾—é‡‘å¸</div>
                    <div class="batch-sell-total-value" id="batch-total-value">${state.price}</div>
                </div>
                <div class="batch-sell-actions">
                    <button class="batch-sell-btn cancel" onclick="BatchSell.close()">å–æ¶ˆ</button>
                    <button class="batch-sell-btn confirm" id="batch-confirm-btn" onclick="BatchSell.confirm()">å”®å–</button>
                </div>
            `;

            isOpen = true;
            overlay.classList.add('show');
            setTimeout(() => {
                const input = document.getElementById('batch-qty-input');
                if (input) { input.value = 1; input.focus(); }
                BatchSell.updateTotal();
            }, 50);
        }

        function adjust(delta) {
            const input = document.getElementById('batch-qty-input');
            if (!input) return;
            const currentQty = parseValidQty(input.value, state.maxQty);
            const newQty = Math.max(1, Math.min(state.maxQty, currentQty + delta));
            input.value = newQty;
            BatchSell.updateTotal();
        }

        function setMax() {
            const input = document.getElementById('batch-qty-input');
            if (input) {
                input.value = state.maxQty;
                BatchSell.updateTotal();
            }
        }

        function updateTotal() {
            const input = document.getElementById('batch-qty-input');
            const totalEl = document.getElementById('batch-total-value');
            const confirmBtn = document.getElementById('batch-confirm-btn');
            if (!input || !totalEl || !confirmBtn) return;

            const qty = parseValidQty(input.value, state.maxQty);
            const total = qty * state.price;
            totalEl.innerText = total;
            confirmBtn.disabled = qty <= 0;
        }

        function confirm() {
            const input = document.getElementById('batch-qty-input');
            if (!input) return;

            // åˆ·æ–°æ•°é‡ï¼ˆé˜²æ­¢é¢æ¿æ‰“å¼€æœŸé—´ç‰©å“è¢«æ¶ˆè€—ï¼‰
            const freshQty = refreshCurrentQty();
            const qty = parseValidQty(input.value, freshQty);

            if (qty <= 0) { showToast('æ•°é‡æ— æ•ˆ'); return; }
            if (freshQty < qty) { showToast('æ•°é‡ä¸è¶³ï¼Œå·²åˆ·æ–°'); BatchSell.close(); return; }

            let toastMsg = '';
            if (state.type === 'crop') {
                state.inventory.crops[state.id] -= qty;
                state.coins += qty * state.price;
                toastMsg = `å”®å– ${qty}ä¸ª ${state.name}`;
            } else if (state.type === 'food') {
                state.inventory.foods[state.id] -= qty;
                state.coins += qty * state.price;
                toastMsg = `å”®å– ${qty}ä»½ ${state.name}`;
            } else if (state.type === 'alcohol') {
                state.inventory.alcohols[state.id] -= qty;
                state.coins += qty * state.price;
                toastMsg = `å”®å– ${qty}ç“¶ ${state.name}`;
            }

            updateHeader();
            renderInventory();
            renderAlcoholInventory?.();
            playSound('coin');
            showToast(`${toastMsg}ï¼Œè·å¾— ${qty * state.price}é‡‘`);
            BatchSell.close();
        }

        function close() {
            const overlay = document.getElementById('batch-sell-overlay');
            if (overlay) overlay.classList.remove('show');
            // æ¢å¤èƒŒæ™¯æ»šåŠ¨
            document.body.style.overflow = '';
            isOpen = false;
            // é‡ç½®çŠ¶æ€
            state = { type: null, id: null, name: '', emoji: '', price: 0, maxQty: 0, lunarBonus: null };
        }

        function handleOverlayClick(event) {
            if (event.target === event.currentTarget) {
                BatchSell.close();
            }
        }

        // æš´éœ²å…¬å¼€ API
        return {
            open: open,
            openFood: openFood,
            openAlcohol: openAlcohol,
            adjust: adjust,
            setMax: setMax,
            updateTotal: updateTotal,
            confirm: confirm,
            close: close
        };
    })();

    // --- æ¸²æŸ“é€»è¾‘ ---
    function renderAll() {
        updateHeader();
        updateToolsUI();
        renderShop();
        renderOrders();
        renderInventory();
        renderKitchen();
        renderBuildings();
        state.farm.forEach((_, i) => renderFarmCell(i));
    }

    function updateHeader() {
        document.getElementById('coins').innerText = state.coins;
    }

    function updateToolsUI() {
        document.querySelectorAll('.tool-btn').forEach(btn => {
            const t = btn.dataset.tool;
            if (!state.selectedSeed && state.tool === t) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });

        const currentToolLabel = document.getElementById('current-tool-label');
        if (currentToolLabel) {
            if (state.selectedSeed && CROPS[state.selectedSeed]) {
                currentToolLabel.innerText = `ç§æ¤Â·${CROPS[state.selectedSeed].name}`;
            } else {
                const toolNames = {
                    hand: 'æŸ¥çœ‹',
                    hoe: 'å¼€å¦',
                    water: 'æµ‡æ°´',
                    scythe: 'æ”¶è·',
                    fertilizer: 'æ–½è‚¥',
                    basket: 'æ”¶é›†',
                    shovel: 'é“²é™¤'
                };
                currentToolLabel.innerText = toolNames[state.tool] || 'æŸ¥çœ‹';
            }
        }

        const fertCount = document.getElementById('fert-count');
        if (fertCount) {
            const n = state.inventory.fertilizer || 0;
            fertCount.innerText = n > 0 ? String(n) : '';
            fertCount.style.display = n > 0 ? 'inline-flex' : 'none';
        }
    }

    function renderFarmCell(idx) {
        const cell = state.farm[idx];
        const el = document.querySelector(`.farm-cell[data-index="${idx}"]`);
        const now = Date.now();

        if (!el) return;
        
        el.className = 'farm-cell'; 
        if (cell.locked) {
            el.classList.add('locked');
            el.innerHTML = '';
            const overlay = document.createElement('div');
            overlay.className = 'lock-overlay';
            overlay.innerHTML = `
                <div class="lock-icon">ğŸ”’</div>
                <div class="lock-price">${getLandUnlockPrice(idx)}é‡‘</div>
            `;
            el.appendChild(overlay);
            return;
        }
        if (cell.type === 'tilled') el.classList.add('tilled');
        if (cell.waterUntil > now) el.classList.add('watered');
        if (!cell.cropId && cell.weed) el.classList.add('weedy');
        if (isNight && isCellLit(idx)) el.classList.add('lit');

        // ä¿ç•™ progress-container
        let container = el.querySelector('.progress-container');
        if (!container) {
            container = document.createElement('div');
            container.className = 'progress-container';
            container.style.display = 'none';

            const text = document.createElement('div');
            text.className = 'progress-text';

            const bar = document.createElement('div');
            bar.className = 'progress-bar';
            bar.innerHTML = '<div class="progress-fill"></div>';

            container.appendChild(text);
            container.appendChild(bar);
        }
        el.innerHTML = '';
        el.appendChild(container);

        if (isLampPlacedAt(idx)) {
            const marker = document.createElement('div');
            marker.className = 'lamp-marker';
            marker.innerText = 'ğŸ®';
            el.appendChild(marker);
        }

        if (cell.cropId) {
            const crop = CROPS[cell.cropId];
            const p = cell.progress || 0;
            
            let displayEmoji = '';
            if (p >= 100) displayEmoji = crop.emoji;
            else if (p > 50) displayEmoji = 'ğŸŒ¿';
            else displayEmoji = 'ğŸŒ±';

            const sprite = document.createElement('div');
            sprite.className = 'crop-sprite';
            sprite.innerText = displayEmoji;
            el.appendChild(sprite);

            if (p < 100) {
                container.style.display = 'flex';
            } else {
                container.style.display = 'none';
            }
        } else if (cell.weed) {
            const sprite = document.createElement('div');
            sprite.className = 'crop-sprite';
            sprite.innerText = CROPS.weed.emoji;
            el.appendChild(sprite);
            container.style.display = 'none';
        } else {
            container.style.display = 'none';
        }
    }

    function updateFarmVisuals() {
        const now = Date.now();
        state.farm.forEach((cell, idx) => {
            if (cell.locked) return;
            if (cell.cropId) {
                const el = document.querySelector(`.farm-cell[data-index="${idx}"]`);
                if (!el) return;
                const container = el.querySelector('.progress-container');
                const text = el.querySelector('.progress-text');
                const fill = el.querySelector('.progress-fill');
                const sprite = el.querySelector('.crop-sprite');
                const crop = CROPS[cell.cropId];
                
                // è®¡ç®—å‰©ä½™ç§’æ•°
                const p = Math.max(0, Math.min(100, cell.progress || 0));
                const remainingPercent = 100 - p;
                const isWatered = cell.waterUntil > now;

                let baseMultiplier = 1;
                if (cell.fertilized) baseMultiplier *= 1.5;
                if (crop.trait && crop.trait.type === 'speed' && typeof crop.trait.val === 'number') baseMultiplier *= crop.trait.val;
                if (crop.growth_bonus) {
                    if (crop.growth_bonus === 'night' && isNight) baseMultiplier *= 2;
                    if (crop.growth_bonus === 'day' && !isNight) baseMultiplier *= 2;
                }

                const baseRate = crop.time > 0 ? (100 / crop.time) * baseMultiplier : 0;

                let remainingSec = 0;
                if (baseRate > 0) {
                    const waterRemainingSec = Math.max(0, (cell.waterUntil || 0) - now) / 1000;
                    if (waterRemainingSec > 0) {
                        const wateredRate = baseRate * 2;
                        const wateredGain = wateredRate * waterRemainingSec;
                        if (remainingPercent <= wateredGain) {
                            remainingSec = remainingPercent / wateredRate;
                        } else {
                            remainingSec = waterRemainingSec + (remainingPercent - wateredGain) / baseRate;
                        }
                    } else {
                        remainingSec = remainingPercent / baseRate;
                    }
                }

                remainingSec = Math.max(0, Math.ceil(remainingSec));

                if (cell.progress < 100) {
                    container.style.display = 'flex';
                    fill.style.width = p + '%';
                    text.innerText = remainingSec + 's';
                    fill.style.backgroundColor = isWatered ? '#0984e3' : '#00b894';
                } else {
                    container.style.display = 'none';
                    if (sprite && sprite.innerText !== crop.emoji) {
                        sprite.innerText = crop.emoji;
                    }
                }
            }
            
            if (cell.type !== 'wild') {
                const el = document.querySelector(`.farm-cell[data-index="${idx}"]`);
                if (!el) return;
                if (cell.waterUntil > now) el.classList.add('watered');
                else el.classList.remove('watered');
            }
        });
    }

    function craftFertilizer() {
        if ((state.inventory.crops['weed'] || 0) >= 2) {
            state.inventory.crops['weed'] -= 2;
            state.inventory.fertilizer++;
            renderInventory();
            updateToolsUI();
            showToast("åˆ¶ä½œäº† 1x è‚¥æ–™");
            playSound('craft');
        } else {
            showToast("æ‚è‰ä¸è¶³ (éœ€è¦2ä¸ª)");
        }
    }

    function getCropSeasonBucket(crop) {
        if (!crop) return 2;
        const seasons = Array.isArray(crop.seasons) ? crop.seasons : [];
        if (seasons.length === 0) return 1;
        return seasons.includes(currentSeason) ? 0 : 2;
    }

    function sortCropIdsBySeason(ids) {
        return ids
            .filter(id => CROPS[id])
            .slice()
            .sort((a, b) => {
                const ca = CROPS[a];
                const cb = CROPS[b];
                const ba = getCropSeasonBucket(ca);
                const bb = getCropSeasonBucket(cb);
                if (ba !== bb) return ba - bb;
                const pa = Number(ca.price || 0) || 0;
                const pb = Number(cb.price || 0) || 0;
                if (pa !== pb) return pa - pb;
                return String(ca.name || a).localeCompare(String(cb.name || b), 'zh-CN');
            });
    }

    function canCraftRecipe(recipe) {
        if (!recipe || !recipe.req) return false;
        for (let ing in recipe.req) {
            if ((state.inventory.crops[ing] || 0) < recipe.req[ing]) return false;
        }
        return true;
    }

    function renderInventory() {
        const invSummary = document.getElementById('inventory-summary');
        if (invSummary) {
            const seedTotal = Object.values(state.inventory.seeds).reduce((a, b) => a + (b || 0), 0);
            const cropTotal = Object.values(state.inventory.crops).reduce((a, b) => a + (b || 0), 0);
            const foodTotal = Object.values(state.inventory.foods).reduce((a, b) => a + (b || 0), 0);
            const alcoholTotal = Object.values(state.inventory.alcohols || {}).reduce((a, b) => a + (b || 0), 0);
            const fert = state.inventory.fertilizer || 0;
            const batteries = state.inventory.batteries || 0;
            const robotOwned = !!state.robot?.owned;
            const robotEnergy = state.robot?.energy || 0;
            const robotMax = state.robot?.maxEnergy || SHOP.robotMaxEnergy;
            const canCharge = robotOwned && batteries > 0 && robotEnergy < robotMax;
            invSummary.innerHTML = `
                <div class="soft-row" style="margin-bottom:10px; padding:10px; border-radius:12px; background:var(--glass-bg); border:1px solid var(--glass-border);">
                    <div style="display:flex; align-items:center; gap:8px; color: var(--text-muted); font-size:12px;">
                        <span class="badge" style="background:rgba(9,132,227,0.10); border-color:rgba(9,132,227,0.16);">ç§å­ ${seedTotal}</span>
                        <span class="badge" style="background:rgba(0,184,148,0.10); border-color:rgba(0,184,148,0.16); color:rgba(0,184,148,0.95);">ä½œç‰© ${cropTotal}</span>
                        <span class="badge" style="background:rgba(253,203,110,0.18); border-color:rgba(211,84,0,0.16); color:rgba(211,84,0,0.9);">æ–™ç† ${foodTotal}</span>
                        <span class="badge" style="background:rgba(162,155,254,0.14); border-color:rgba(162,155,254,0.22); color:rgba(108,92,231,0.95);">é…’ ${alcoholTotal}</span>
                    </div>
                    <div style="display:flex; align-items:center; gap:8px;">
                        <span class="badge" style="background:rgba(162,155,254,0.14); border-color:rgba(162,155,254,0.22); color:rgba(108,92,231,0.95);">è‚¥æ–™ ${fert}</span>
                        <span class="badge" style="background:rgba(162,155,254,0.14); border-color:rgba(162,155,254,0.22); color:rgba(108,92,231,0.95);">ç”µæ±  ${batteries}</span>
                    </div>
                </div>

                ${robotOwned ? `
                    <div class="soft-row" style="margin-bottom:10px; padding:10px; border-radius:12px; background:var(--glass-bg); border:1px solid var(--glass-border);">
                        <div style="display:flex; align-items:center; gap:10px;">
                            <div style="font-weight:900; color: var(--text-main);">ğŸ¤– è‡ªåŠ¨æ”¶å‰²</div>
                            <div style="font-size:12px; color: var(--text-muted);">ç”µé‡ ${robotEnergy}/${robotMax}</div>
                        </div>
                        <button class="btn-soft primary" style="padding:6px 10px; border-radius:12px;" ${canCharge ? '' : 'disabled'} onclick="useBattery()">å……ç”µ</button>
                    </div>
                ` : ''}
            `;
        }

        renderBreweryPanel();

        const seedContainer = document.getElementById('seed-list');
        seedContainer.innerHTML = '';
        const seeds = sortCropIdsBySeason(Object.keys(state.inventory.seeds));
        
        let hasItems = false;

        seedContainer.insertAdjacentHTML('beforeend', `<div class="section-title">ğŸ“¦ ç§å­ <span class="muted">ç‚¹å‡»ä½¿ç”¨ç§æ¤</span></div>`);

        seeds.forEach(id => {
            const count = state.inventory.seeds[id];
            if (count > 0) {
                hasItems = true;
                const crop = CROPS[id];
                const lunarBonus = getLunarCropBonus(id);
                const div = document.createElement('div');
                div.className = 'list-item';
                div.innerHTML = `
                    <div class="item-icon">ğŸ“¦</div>
                    <div class="item-details">
                        <div class="item-name">${crop.name}ç§å­ <span class="badge" style="background:rgba(9,132,227,0.10); border-color:rgba(9,132,227,0.16);">${count}</span>${lunarBonus.active ? `<span class="badge" style="background:rgba(253,203,110,0.18); border-color:rgba(211,84,0,0.16); color:rgba(211,84,0,0.9);">å†œå†æ—º</span>` : ''}</div>
                        <div class="item-sub">${lunarBonus.active ? `æœ¬æœˆæ—ºç§ï¼šæ”¶è·+${lunarBonus.yieldExtra}ï½œå–ä»·Ã—${lunarBonus.sellMul}` : `æ‹¥æœ‰: ${count}`}</div>
                    </div>
                    <button class="item-action btn-use ${state.selectedSeed === id ? 'active' : ''}" 
                        onclick="selectSeed('${id}')">
                        ${state.selectedSeed === id ? 'ç§æ¤ä¸­' : 'ä½¿ç”¨'}
                    </button>
                `;
                seedContainer.appendChild(div);
            }
        });

        const cropContainer = document.getElementById('crop-list');
        cropContainer.innerHTML = '';
        cropContainer.insertAdjacentHTML('beforeend', `<div class="section-title">ğŸŒ¾ ä½œç‰© <span class="muted">å¯å‡ºå”®/å¯åˆ¶ä½œ</span></div>`);
        Object.keys(state.inventory.crops).forEach(id => {
            const count = state.inventory.crops[id];
            if (count > 0) {
                hasItems = true;
                const crop = CROPS[id];
                const lunarBonus = getLunarCropBonus(id);
                const div = document.createElement('div');
                div.className = 'list-item';
                let extraBtn = '';
                if (id === 'weed') {
                    extraBtn = `<button class="item-action btn-use" style="margin-right:5px; background:#a29bfe; color:white;" onclick="craftFertilizer()">åˆ¶è‚¥(2ğŸŒ¿)</button>`;
                }

                const sellPrice = Math.round(crop.sell * (lunarBonus.active ? lunarBonus.sellMul : 1));
                const batchBtn = count > 1 ? `<button class="btn-batch-sell" onclick="BatchSell.open('${id}')" title="æ‰¹é‡å”®å–">ğŸ“¦ ${count > 9 ? '' : count}</button>` : '';

                div.innerHTML = `
                    <div class="item-icon">${crop.emoji}</div>
                    <div class="item-details">
                        <div class="item-name">${crop.name} <span class="badge" style="background:rgba(0,184,148,0.10); border-color:rgba(0,184,148,0.16); color:rgba(0,184,148,0.95);">${count}</span>${lunarBonus.active ? `<span class="badge" style="background:rgba(253,203,110,0.18); border-color:rgba(211,84,0,0.16); color:rgba(211,84,0,0.9);">å†œå†æ—º</span>` : ''}</div>
                        <div class="item-sub">å•ä»·: ${crop.sell}é‡‘${lunarBonus.active ? `ï¼ˆÃ—${lunarBonus.sellMul}ï¼‰` : ''}</div>
                    </div>
                    ${extraBtn}
                    ${batchBtn}
                    <button class="item-action btn-sell" onclick="sellCrop('${id}')">
                        å– ${sellPrice}é‡‘
                    </button>
                `;
                cropContainer.appendChild(div);
            }
        });
        const foodContainer = document.getElementById('food-list');
        if (foodContainer) {
            foodContainer.innerHTML = '';
            foodContainer.insertAdjacentHTML('beforeend', `<div class="section-title">ğŸ³ æ–™ç† <span class="muted">æ¥è‡ªå¨æˆ¿åˆ¶ä½œ</span></div>`);
            Object.keys(state.inventory.foods).forEach(k => {
                const count = state.inventory.foods[k];
                if (count > 0) {
                    hasItems = true;
                    const r = RECIPES[k];
                    if (!r) return;
                    const div = document.createElement('div');
                    div.className = 'list-item';
                    const batchBtn = count > 1 ? `<button class="btn-batch-sell" onclick="BatchSell.openFood(${k})" title="æ‰¹é‡å”®å–">ğŸ“¦ ${count > 9 ? '' : count}</button>` : '';

                    div.innerHTML = `
                        <div class="item-icon">${r.emoji}</div>
                        <div class="item-details">
                            <div class="item-name">${r.name} <span class="badge" style="background:rgba(253,203,110,0.20); border-color:rgba(211,84,0,0.16); color:rgba(211,84,0,0.9);">${count}</span></div>
                            <div class="item-sub">å•ä»·: ${r.price}é‡‘</div>
                        </div>
                        ${batchBtn}
                        <button class="item-action btn-sell" onclick="sellFood(${k})">
                            å– ${r.price}é‡‘
                        </button>
                    `;
                    foodContainer.appendChild(div);
                }
            });
        }

        const hasAlcohol = renderAlcoholInventory();
        if (hasAlcohol) hasItems = true;
        
        if (!hasItems && !hasBuilding('brewery')) {
            seedContainer.innerHTML = '<div style="text-align:center; color:var(--text-muted); padding:20px;">èƒŒåŒ…ç©ºç©ºçš„</div>';
            cropContainer.innerHTML = '';
            if (foodContainer) foodContainer.innerHTML = '';
            const alcoholContainer = document.getElementById('alcohol-list');
            if (alcoholContainer) alcoholContainer.innerHTML = '';
        }
    }

    function sanitizeBreweryState(raw) {
        const base = { slots: [] };
        const src = raw && typeof raw === 'object' ? raw : base;
        const slots = Array.isArray(src.slots) ? src.slots : [];
        const out = [];
        for (let i = 0; i < BREW.slotCount; i++) {
            const s = slots[i] && typeof slots[i] === 'object' ? slots[i] : null;
            if (!s) {
                out.push(null);
                continue;
            }
            const cropId = typeof s.cropId === 'string' ? s.cropId : null;
            const cropQty = typeof s.cropQty === 'number' ? Math.max(1, Math.floor(s.cropQty)) : 1;
            const startedAt = typeof s.startedAt === 'number' ? s.startedAt : 0;
            const doneAt = typeof s.doneAt === 'number' ? s.doneAt : 0;
            if (!cropId || !CROPS[cropId] || doneAt <= 0) {
                out.push(null);
                continue;
            }
            out.push({ cropId, cropQty, startedAt, doneAt });
        }
        return { slots: out };
    }

    function isBrewableCrop(cropId) {
        if (!cropId || !CROPS[cropId]) return false;
        if (cropId === 'weed' || cropId === 'bamboo') return false;
        return (
            BREW.fruit.has(cropId) ||
            BREW.grain.has(cropId) ||
            BREW.starchy.has(cropId) ||
            BREW.herb.has(cropId) ||
            cropId === 'sugarcane'
        );
    }

    function getBrewKind(cropId) {
        if (!isBrewableCrop(cropId)) return null;
        if (cropId === 'rice') return 'sake';
        if (cropId === 'potato') return 'vodka';
        if (cropId === 'sugarcane') return 'rum';
        if (cropId === 'rye' || cropId === 'corn') return 'whiskey';
        if (cropId === 'hops' || BREW.grain.has(cropId)) return 'beer';
        if (BREW.fruit.has(cropId)) return 'wine';
        if (BREW.starchy.has(cropId)) return 'shochu';
        if (BREW.herb.has(cropId)) return 'liqueur';
        return null;
    }

    function getBrewInputCount(cropId) {
        const crop = CROPS[cropId];
        const s = Number(crop?.sell || 0) || 0;
        if (s >= 1000) return 1;
        if (s >= 200) return 2;
        if (s >= 80) return 3;
        return 5;
    }

    function getDrinkIdForCrop(cropId) {
        return `brew:${cropId}`;
    }

    function getDrinkSpecForCrop(cropId) {
        const crop = CROPS[cropId];
        if (!crop) return null;
        const kind = getBrewKind(cropId);
        if (!kind) return null;

        const inputCount = getBrewInputCount(cropId);
        const baseMsByKind = {
            beer: 8 * 60 * 1000,
            wine: 15 * 60 * 1000,
            whiskey: 22 * 60 * 1000,
            vodka: 18 * 60 * 1000,
            rum: 20 * 60 * 1000,
            sake: 16 * 60 * 1000,
            shochu: 18 * 60 * 1000,
            liqueur: 12 * 60 * 1000
        };
        const multByKind = {
            beer: 1.8,
            wine: 2.4,
            whiskey: 3.0,
            vodka: 2.6,
            rum: 2.8,
            sake: 2.5,
            shochu: 2.6,
            liqueur: 2.2
        };
        const emojiByKind = {
            beer: 'ğŸº',
            wine: 'ğŸ·',
            whiskey: 'ğŸ¥ƒ',
            vodka: 'ğŸ¥ƒ',
            rum: 'ğŸ¥ƒ',
            sake: 'ğŸ¶',
            shochu: 'ğŸ¶',
            liqueur: 'ğŸ¥ƒ'
        };
        const baseMs = baseMsByKind[kind] || (12 * 60 * 1000);
        const scale = Math.min(2.5, 1 + (Number(crop.sell || 0) || 0) / 300);
        const brewMs = Math.max(60 * 1000, Math.round(baseMs * scale));

        let name = '';
        if (cropId === 'grape') name = 'è‘¡è„é…’';
        else if (cropId === 'apple') name = 'è‹¹æœé…’';
        else if (cropId === 'rice') name = 'æ¸…é…’';
        else if (cropId === 'hops') name = 'å•¤é…’';
        else if (cropId === 'potato') name = 'ä¼ç‰¹åŠ ';
        else if (cropId === 'sugarcane') name = 'æœ—å§†é…’';
        else if (cropId === 'rye') name = 'é»‘éº¦å¨å£«å¿Œ';
        else if (cropId === 'corn') name = 'ç‰ç±³å¨å£«å¿Œ';
        else if (kind === 'wine') name = `${crop.name}æœé…’`;
        else if (kind === 'beer') name = `${crop.name}å•¤é…’`;
        else if (kind === 'whiskey') name = `${crop.name}å¨å£«å¿Œ`;
        else if (kind === 'vodka') name = `${crop.name}ä¼ç‰¹åŠ `;
        else if (kind === 'rum') name = `${crop.name}æœ—å§†`;
        else if (kind === 'sake') name = `${crop.name}æ¸…é…’`;
        else if (kind === 'shochu') name = `${crop.name}çƒ§é…’`;
        else if (kind === 'liqueur') name = `${crop.name}åˆ©å£é…’`;
        else name = `${crop.name}é…’`;

        const sell = Math.max(1, Math.round((Number(crop.sell || 0) || 0) * inputCount * (multByKind[kind] || 2)));
        return {
            id: getDrinkIdForCrop(cropId),
            cropId,
            cropQty: inputCount,
            kind,
            name,
            emoji: emojiByKind[kind] || 'ğŸ¶',
            brewMs,
            sell
        };
    }

    function getDrinkSpecByDrinkId(drinkId) {
        if (typeof drinkId !== 'string') return null;
        if (!drinkId.startsWith('brew:')) return null;
        const cropId = drinkId.slice('brew:'.length);
        return getDrinkSpecForCrop(cropId);
    }

    function startBrewing(slotIndex, cropId) {
        if (!hasBuilding('brewery')) {
            showToast('è¿˜æ²¡æœ‰é…¿é…’æ¡¶ï¼Œå»å•†åº—ä¹°ä¸€ä¸ª');
            return;
        }
        if (!isBrewableCrop(cropId)) {
            showToast('è¿™ä¸ªä½œç‰©ä¸å¤ªé€‚åˆæ‹¿æ¥é…¿é…’');
            return;
        }
        const spec = getDrinkSpecForCrop(cropId);
        if (!spec) return;

        const slots = state.brewery?.slots || [];
        const cur = slots[slotIndex] || null;
        if (cur) {
            showToast('è¿™ä¸ªæ¡¶æ­£åœ¨ä½¿ç”¨ä¸­');
            return;
        }
        const have = state.inventory.crops[cropId] || 0;
        if (have < spec.cropQty) {
            showToast(`ææ–™ä¸è¶³ï¼šéœ€è¦ ${CROPS[cropId].name} x${spec.cropQty}`);
            return;
        }

        state.inventory.crops[cropId] = have - spec.cropQty;
        const now = Date.now();
        slots[slotIndex] = { cropId, cropQty: spec.cropQty, startedAt: now, doneAt: now + spec.brewMs };
        state.brewery.slots = slots;
        renderInventory();
        renderShop();
        playSound('craft');
        showToast(`å¼€å§‹é…¿é€ ï¼š${spec.emoji} ${spec.name}`);
    }

    function collectBrew(slotIndex) {
        const slots = state.brewery?.slots || [];
        const cur = slots[slotIndex] || null;
        if (!cur) return;
        const now = Date.now();
        if ((cur.doneAt || 0) > now) {
            showToast('è¿˜æ²¡é…¿å¥½ï¼Œå†ç­‰ç­‰');
            return;
        }
        const spec = getDrinkSpecForCrop(cur.cropId);
        if (!spec) {
            slots[slotIndex] = null;
            state.brewery.slots = slots;
            renderBreweryPanel();
            return;
        }
        const inv = state.inventory.alcohols || {};
        inv[spec.id] = (inv[spec.id] || 0) + 1;
        state.inventory.alcohols = inv;
        slots[slotIndex] = null;
        state.brewery.slots = slots;
        renderInventory();
        playSound('harvest');
        showToast(`å–å‡ºå®Œæˆï¼š${spec.emoji} ${spec.name}`, 'success');
    }

    function ensureBreweryState() {
        if (!state.brewery || typeof state.brewery !== 'object') state.brewery = { slots: [] };
        if (!Array.isArray(state.brewery.slots)) state.brewery.slots = [];
        if (state.brewery.slots.length < BREW.slotCount) {
            for (let i = state.brewery.slots.length; i < BREW.slotCount; i++) state.brewery.slots.push(null);
        } else if (state.brewery.slots.length > BREW.slotCount) {
            state.brewery.slots = state.brewery.slots.slice(0, BREW.slotCount);
        }
    }

    function breweryTick(now) {
        ensureBreweryState();
        const panel = document.getElementById('brewery-panel');
        if (!panel) return;
        const active = document.getElementById('tab-inventory');
        if (!active || !active.classList.contains('active')) return;
        if (!hasBuilding('brewery')) return;
        const slots = state.brewery.slots || [];
        let needs = false;
        for (let i = 0; i < slots.length; i++) {
            const s = slots[i];
            if (!s) continue;
            needs = true;
            break;
        }
        if (!needs) return;
        renderBreweryPanel();
    }

    function renderBreweryPanel() {
        const container = document.getElementById('brewery-panel');
        if (!container) return;
        ensureBreweryState();

        if (!hasBuilding('brewery')) {
            container.innerHTML = '';
            return;
        }

        const now = Date.now();
        const slots = state.brewery.slots || [];
        container.innerHTML = '';
        container.insertAdjacentHTML('beforeend', `<div class="section-title">ğŸº é…¿é…’æ¡¶ <span class="muted">æ—¶é—´æ¯”è¾ƒä¹…</span></div>`);

        for (let i = 0; i < slots.length; i++) {
            const s = slots[i];
            const div = document.createElement('div');
            div.className = 'list-item';

            if (!s) {
                const options = Object.keys(state.inventory.crops || {})
                    .filter(id => isBrewableCrop(id))
                    .map(id => {
                        const spec = getDrinkSpecForCrop(id);
                        const have = state.inventory.crops[id] || 0;
                        if (!spec) return null;
                        if (have < spec.cropQty) return null;
                        return { id, spec, have };
                    })
                    .filter(Boolean)
                    .sort((a, b) => (Number(b.spec.sell || 0) - Number(a.spec.sell || 0)) || String(a.spec.name || '').localeCompare(String(b.spec.name || ''), 'zh-CN'));

                const selectId = `brew-slot-${i}-select`;
                const optHtml = options.length
                    ? options.map(o => `<option value="${o.id}">${CROPS[o.id].name} x${o.spec.cropQty} â†’ ${o.spec.name}</option>`).join('')
                    : `<option value="">æ²¡æœ‰å¯ç”¨ææ–™</option>`;

                div.innerHTML = `
                    <div class="item-icon">ğŸªµ</div>
                    <div class="item-details">
                        <div class="item-name">æ¡¶ä½ ${i + 1} <span class="badge" style="background:rgba(9,132,227,0.10); border-color:rgba(9,132,227,0.16);">ç©ºé—²</span></div>
                        <div class="item-sub">
                            <select id="${selectId}" style="width:100%; padding:6px 8px; border-radius:10px; border:1px solid rgba(0,0,0,0.08); background:rgba(255,255,255,0.8);">
                                ${optHtml}
                            </select>
                        </div>
                    </div>
                    <button class="item-action btn-buy" ${options.length ? '' : 'disabled'} onclick="startBrewing(${i}, document.getElementById('${selectId}').value)">
                        å¼€å§‹
                    </button>
                `;
                container.appendChild(div);
                continue;
            }

            const spec = getDrinkSpecForCrop(s.cropId);
            const remainSec = Math.max(0, Math.ceil(((s.doneAt || 0) - now) / 1000));
            const ready = remainSec <= 0;
            div.innerHTML = `
                <div class="item-icon">${spec ? spec.emoji : 'ğŸ¶'}</div>
                <div class="item-details">
                    <div class="item-name">${spec ? spec.name : 'é…¿é€ ä¸­'} ${ready ? '<span class="badge" style="background:rgba(0,184,148,0.10); border-color:rgba(0,184,148,0.16); color:rgba(0,184,148,0.95);">å·²å®Œæˆ</span>' : '<span class="badge" style="background:rgba(253,203,110,0.20); border-color:rgba(211,84,0,0.16); color:rgba(211,84,0,0.9);">é…¿é€ ä¸­</span>'}</div>
                    <div class="item-sub">${spec ? `${CROPS[s.cropId].name} x${s.cropQty}` : ''} ${ready ? 'å¯ä»¥å–å‡ºäº†' : `å‰©ä½™ ${remainSec}s`}</div>
                </div>
                <button class="item-action btn-buy" onclick="collectBrew(${i})" ${ready ? '' : 'disabled'}>å–å‡º</button>
            `;
            container.appendChild(div);
        }
    }

    function renderAlcoholInventory() {
        const container = document.getElementById('alcohol-list');
        if (!container) return false;
        container.innerHTML = '';
        container.insertAdjacentHTML('beforeend', `<div class="section-title">ğŸ· é…’ <span class="muted">æ¥è‡ªé…¿é…’æ¡¶</span></div>`);
        const inv = state.inventory.alcohols || {};
        const ids = Object.keys(inv).filter(k => (inv[k] || 0) > 0);
        if (ids.length === 0) {
            container.insertAdjacentHTML('beforeend', `<div style="text-align:center; color:var(--text-muted); padding:10px 0;">è¿˜æ²¡æœ‰é…¿å‡ºé…’</div>`);
            return false;
        }
        ids
            .map(id => ({ id, spec: getDrinkSpecByDrinkId(id), count: inv[id] || 0 }))
            .filter(x => x.spec && x.count > 0)
            .sort((a, b) => (Number(b.spec.sell || 0) - Number(a.spec.sell || 0)) || String(a.spec.name || '').localeCompare(String(b.spec.name || ''), 'zh-CN'))
            .forEach(x => {
                const div = document.createElement('div');
                div.className = 'list-item';
                const batchBtn = x.count > 1 ? `<button class="btn-batch-sell" onclick="BatchSell.openAlcohol('${x.id}')" title="æ‰¹é‡å”®å–">ğŸ“¦ ${x.count > 9 ? '' : x.count}</button>` : '';

                div.innerHTML = `
                    <div class="item-icon">${x.spec.emoji}</div>
                    <div class="item-details">
                        <div class="item-name">${x.spec.name} <span class="badge" style="background:rgba(162,155,254,0.14); border-color:rgba(162,155,254,0.22); color:rgba(108,92,231,0.95);">${x.count}</span></div>
                        <div class="item-sub">å•ä»·: ${x.spec.sell}é‡‘</div>
                    </div>
                    ${batchBtn}
                    <button class="item-action btn-sell" onclick="sellAlcohol('${x.id}')">
                        å– ${x.spec.sell}é‡‘
                    </button>
                `;
                container.appendChild(div);
            });
        return true;
    }

    function renderShop() {
        const container = document.getElementById('shop-list');
        container.innerHTML = '';

        container.insertAdjacentHTML('beforeend', `<div class="section-title">ğŸŒ± ç§å­ <span class="muted">è´­ä¹°åå¯åœ¨èƒŒåŒ…ä½¿ç”¨</span></div>`);

        const seedIds = sortCropIdsBySeason(
            Object.keys(CROPS).filter(id => {
                const crop = CROPS[id];
                return !!(crop && crop.price && crop.price > 0);
            })
        );

        seedIds.forEach(id => {
            const crop = CROPS[id];

            let traitHtml = '';
            if (crop.seasons && crop.seasons.length > 0) {
                const sIcons = { spring: 'ğŸŒ¸', summer: 'â˜€ï¸', autumn: 'ğŸ', winter: 'â„ï¸' };
                traitHtml += `<span style="margin-left:5px;">${crop.seasons.map(s => sIcons[s]).join('')}</span>`;
            } else {
                traitHtml += `<span style="margin-left:5px;">â™¾ï¸</span>`;
            }

            if (crop.trait) {
                let color = '#0984e3';
                if (crop.trait.type === 'bonus') color = '#e17055';
                if (crop.trait.type === 'speed') color = '#00b894';
                traitHtml += `<span style="font-size:10px; background:${color}; color:white; padding:2px 4px; border-radius:4px; margin-left:5px;">${crop.trait.label}</span>`;
            }

            if (crop.growth_bonus) {
                const icon = crop.growth_bonus === 'night' ? 'ğŸŒ™' : 'â˜€ï¸';
                traitHtml += `<span style="font-size:10px; background:#636e72; color:white; padding:2px 4px; border-radius:4px; margin-left:5px;">${icon}åŠ é€Ÿ</span>`;
            }

            const div = document.createElement('div');
            div.className = 'list-item';
            div.innerHTML = `
                <div class="item-icon">${crop.emoji}</div>
                <div class="item-details">
                    <div class="item-name">${crop.name}ç§å­${traitHtml}</div>
                    <div class="item-sub">${crop.time}ç§’æˆç†Ÿ</div>
                </div>
                <button class="item-action btn-buy" onclick="buySeed('${id}')">
                    ${crop.price}é‡‘
                </button>
            `;
            container.appendChild(div);
        });

        container.insertAdjacentHTML('beforeend', `<div class="section-title">ğŸ“œ é£Ÿè°± <span class="muted">è§£é”åå¯åœ¨å¨æˆ¿åˆ¶ä½œ</span></div>`);

        const lockedRecipes = RECIPES
            .map((r, idx) => ({ r, idx }))
            .filter(x => x.r && x.r.unlockPrice && !x.r.unlocked);

        if (lockedRecipes.length === 0) {
            container.insertAdjacentHTML('beforeend', `<div style="text-align:center; color:var(--text-muted); padding:10px 0;">å·²è§£é”å…¨éƒ¨é£Ÿè°±</div>`);
        } else {
            lockedRecipes.forEach(({ r, idx }) => {
                const reqStr = Object.keys(r.req).map(k => `${CROPS[k]?.name || k}x${r.req[k]}`).join(' ');
                const div = document.createElement('div');
                div.className = 'list-item';
                div.innerHTML = `
                    <div class="item-icon">${r.emoji}</div>
                    <div class="item-details">
                        <div class="item-name">${r.name}</div>
                        <div class="item-sub">ææ–™: ${reqStr}</div>
                    </div>
                    <button class="item-action btn-buy" onclick="buyRecipeUnlock(${idx})">${r.unlockPrice}é‡‘</button>
                `;
                container.appendChild(div);
            });
        }

        container.insertAdjacentHTML('beforeend', `<div class="section-title">ğŸ¤– è‡ªåŠ¨åŒ– <span class="muted">ç¦»çº¿ä¹Ÿä¼šæ”¶å‰²</span></div>`);

        {
            const owned = !!state.robot.owned;
            const energy = state.robot.energy || 0;
            const maxEnergy = state.robot.maxEnergy || SHOP.robotMaxEnergy;
            const div = document.createElement('div');
            div.className = 'list-item';
            div.innerHTML = `
                <div class="item-icon">ğŸ¤–</div>
                <div class="item-details">
                    <div class="item-name">è‡ªåŠ¨æ”¶å‰²æœºå™¨äºº ${owned ? '<span class="badge" style="background:rgba(0,184,148,0.10); border-color:rgba(0,184,148,0.16); color:rgba(0,184,148,0.95);">å·²æ‹¥æœ‰</span>' : ''}</div>
                    <div class="item-sub">åªä¼šæ”¶å‰²æˆç†Ÿä½œç‰©ï½œç”µé‡ ${energy}/${maxEnergy}</div>
                </div>
                ${owned ? `<button class="item-action btn-buy" onclick="useBattery()">å……ç”µ</button>` : `<button class="item-action btn-buy" onclick="buyRobot()">${SHOP.robotPrice}é‡‘</button>`}
            `;
            container.appendChild(div);
        }

        {
            const n = state.inventory.batteries || 0;
            const div = document.createElement('div');
            div.className = 'list-item';
            div.innerHTML = `
                <div class="item-icon">ğŸ”‹</div>
                <div class="item-details">
                    <div class="item-name">ç”µæ±  <span class="badge" style="background:rgba(162,155,254,0.14); border-color:rgba(162,155,254,0.22); color:rgba(108,92,231,0.95);">${n}</span></div>
                    <div class="item-sub">ä¸ºæœºå™¨äººå……ç”µ +${SHOP.batteryCharge}ï½œä¸€æ¬¡æ€§æ¶ˆè€—</div>
                </div>
                <button class="item-action btn-buy" onclick="buyBattery()">${SHOP.batteryPrice}é‡‘</button>
            `;
            container.appendChild(div);
        }

        container.insertAdjacentHTML('beforeend', `<div class="section-title">ğŸ  å»ºç­‘ <span class="muted">ä¼šæ‘†åœ¨å†œç”°æ—è¾¹</span></div>`);

        BUILDINGS.forEach(b => {
            const owned = hasBuilding(b.id);
            const count = getBuildingCount(b.id);
            const div = document.createElement('div');
            div.className = 'list-item';
            div.innerHTML = `
                <div class="item-icon">${b.emoji}</div>
                <div class="item-details">
                    <div class="item-name">${b.name} ${b.kind === 'decor' && count > 0 ? `<span class="badge" style="background:rgba(162,155,254,0.14); border-color:rgba(162,155,254,0.22); color:rgba(108,92,231,0.95);">Ã—${count}</span>` : (owned ? '<span class="badge" style="background:rgba(0,184,148,0.10); border-color:rgba(0,184,148,0.16); color:rgba(0,184,148,0.95);">å·²æ‹¥æœ‰</span>' : '')}</div>
                    <div class="item-sub">${b.desc || ''}</div>
                </div>
                ${b.kind === 'decor' ? `<button class="item-action btn-buy" onclick="buyBuilding('${b.id}')">${b.price}é‡‘</button>` : (owned ? `<button class="item-action btn-buy" disabled>å·²å»ºé€ </button>` : `<button class="item-action btn-buy" onclick="buyBuilding('${b.id}')">${b.price}é‡‘</button>`)}
            `;
            container.appendChild(div);
        });
    }

    function sanitizeOrdersState(raw, now) {
        const base = { nextRefreshAt: 0, list: [] };
        const src = raw && typeof raw === 'object' ? raw : base;
        const list = Array.isArray(src.list) ? src.list : [];
        const nextRefreshAt = typeof src.nextRefreshAt === 'number' ? src.nextRefreshAt : 0;

        const cleanList = list
            .filter(x => x && typeof x === 'object')
            .map(x => {
                const id = typeof x.id === 'string' ? x.id : '';
                const title = typeof x.title === 'string' ? x.title : 'è®¢å•';
                const reward = typeof x.reward === 'number' ? Math.max(1, Math.floor(x.reward)) : 0;
                const createdAt = typeof x.createdAt === 'number' ? x.createdAt : now;
                const expiresAt = typeof x.expiresAt === 'number' ? x.expiresAt : 0;
                const items = Array.isArray(x.items) ? x.items : [];
                const cleanItems = items
                    .filter(it => it && typeof it === 'object')
                    .map(it => ({
                        type: it.type === 'food' || it.type === 'alcohol' ? it.type : 'crop',
                        key: typeof it.key === 'string' ? it.key : '',
                        qty: typeof it.qty === 'number' ? Math.max(1, Math.floor(it.qty)) : 1
                    }))
                    .filter(it => it.key);
                if (!id || reward <= 0 || cleanItems.length === 0) return null;
                return { id, title, reward, createdAt, expiresAt, items: cleanItems };
            })
            .filter(Boolean);

        const out = { nextRefreshAt, list: cleanList };
        if (!out.nextRefreshAt || out.nextRefreshAt < 0) out.nextRefreshAt = 0;

        if (!out.list.length && now) {
            out.list = generateOrders(now, ORDERS.count);
            out.nextRefreshAt = now + ORDERS.refreshMs;
        }

        if (now && out.nextRefreshAt && now >= out.nextRefreshAt) {
            out.list = generateOrders(now, ORDERS.count);
            out.nextRefreshAt = now + ORDERS.refreshMs;
        }

        return out;
    }

    function ordersTick(now) {
        if (!state.orders || typeof state.orders !== 'object') {
            state.orders = { nextRefreshAt: 0, list: [] };
        }
        if (!Array.isArray(state.orders.list)) state.orders.list = [];

        if (!state.orders.nextRefreshAt || state.orders.nextRefreshAt <= 0) {
            state.orders.list = generateOrders(now, ORDERS.count);
            state.orders.nextRefreshAt = now + ORDERS.refreshMs;
            return;
        }

        if (now >= state.orders.nextRefreshAt) {
            state.orders.list = generateOrders(now, ORDERS.count);
            state.orders.nextRefreshAt = now + ORDERS.refreshMs;
            showToast('ğŸ“¦ æ–°è®¢å•å·²åˆ·æ–°', 'success');
            const active = document.getElementById('tab-orders');
            if (active && active.classList.contains('active')) renderOrders();
            state.orders.lastRenderAt = now;
            return;
        }

        const active = document.getElementById('tab-orders');
        if (active && active.classList.contains('active')) {
            const last = typeof state.orders.lastRenderAt === 'number' ? state.orders.lastRenderAt : 0;
            if (now - last >= 1000) {
                state.orders.lastRenderAt = now;
                renderOrders();
            }
        }
    }

    function randInt(min, max) {
        const a = Math.ceil(min);
        const b = Math.floor(max);
        return Math.floor(a + Math.random() * (b - a + 1));
    }

    function pickOne(arr) {
        if (!arr || arr.length === 0) return null;
        return arr[Math.floor(Math.random() * arr.length)];
    }

    function getOrderLineSpec(line) {
        if (!line || typeof line !== 'object') return null;
        if (line.type === 'food') {
            const idx = Number(line.key);
            const r = Number.isFinite(idx) ? RECIPES[idx] : null;
            if (!r) return null;
            return { type: 'food', key: String(idx), name: r.name, emoji: r.emoji, unit: r.price };
        }
        if (line.type === 'alcohol') {
            const spec = getDrinkSpecByDrinkId(line.key);
            if (!spec) return null;
            return { type: 'alcohol', key: spec.id, name: spec.name, emoji: spec.emoji, unit: spec.sell };
        }
        const crop = CROPS[line.key];
        if (!crop) return null;
        return { type: 'crop', key: line.key, name: crop.name, emoji: crop.emoji, unit: crop.sell };
    }

    function getOwnedCountForLine(line) {
        const spec = getOrderLineSpec(line);
        if (!spec) return 0;
        if (spec.type === 'food') return state.inventory.foods[spec.key] || 0;
        if (spec.type === 'alcohol') return (state.inventory.alcohols || {})[spec.key] || 0;
        return state.inventory.crops[spec.key] || 0;
    }

    function canFulfillOrder(order) {
        if (!order || !Array.isArray(order.items)) return false;
        for (const line of order.items) {
            const have = getOwnedCountForLine(line);
            const need = line.qty || 0;
            if (have < need) return false;
        }
        return true;
    }

    function fulfillOrder(orderId) {
        const orders = state.orders && Array.isArray(state.orders.list) ? state.orders.list : [];
        const order = orders.find(o => o && o.id === orderId);
        if (!order) return;
        if (!canFulfillOrder(order)) {
            showToast('ææ–™ä¸è¶³ï¼Œæ— æ³•äº¤ä»˜');
            return;
        }

        for (const line of order.items) {
            const spec = getOrderLineSpec(line);
            if (!spec) continue;
            if (spec.type === 'food') {
                state.inventory.foods[spec.key] = Math.max(0, (state.inventory.foods[spec.key] || 0) - line.qty);
            } else if (spec.type === 'alcohol') {
                const inv = state.inventory.alcohols || {};
                inv[spec.key] = Math.max(0, (inv[spec.key] || 0) - line.qty);
                state.inventory.alcohols = inv;
            } else {
                state.inventory.crops[spec.key] = Math.max(0, (state.inventory.crops[spec.key] || 0) - line.qty);
            }
        }

        state.coins += Math.max(1, Math.floor(order.reward));
        state.orders.list = orders.filter(o => o && o.id !== orderId);

        updateHeader();
        renderInventory();
        renderShop();
        renderOrders();
        playSound('coin');
        showToast(`äº¤ä»˜å®Œæˆ +${Math.floor(order.reward)}é‡‘`, 'success');
    }

    function computeLineQty(unit) {
        const u = Number(unit || 0) || 0;
        if (u <= 0) return 1;
        if (u < 20) return randInt(8, 12);
        if (u < 50) return randInt(5, 8);
        if (u < 100) return randInt(3, 5);
        if (u < 200) return randInt(2, 4);
        if (u < 600) return randInt(1, 2);
        return 1;
    }

    function generateOrders(now, count) {
        const result = [];
        const cropPool = Object.keys(CROPS).filter(id => id && id !== 'weed');
        const foodPool = RECIPES
            .map((r, idx) => ({ r, idx }))
            .filter(x => x.r && (!x.r.unlockPrice || x.r.unlocked))
            .map(x => x.idx);
        const alcoholPool = Object.keys(state.inventory.alcohols || {}).filter(k => (state.inventory.alcohols[k] || 0) > 0);

        for (let i = 0; i < count; i++) {
            const lines = [];
            const wantLines = randInt(1, 2);

            for (let k = 0; k < wantLines; k++) {
                let type = 'crop';
                if (k === 1 && foodPool.length > 0 && Math.random() < 0.6) type = 'food';
                if (k === 0 && foodPool.length > 0 && Math.random() < 0.22) type = 'food';
                if (alcoholPool.length > 0 && Math.random() < 0.10) type = 'alcohol';

                if (type === 'food') {
                    const idx = pickOne(foodPool);
                    const r = RECIPES[idx];
                    if (!r) continue;
                    const qty = Math.max(1, Math.min(3, computeLineQty(r.price)));
                    lines.push({ type: 'food', key: String(idx), qty });
                } else if (type === 'alcohol') {
                    const drinkId = pickOne(alcoholPool);
                    const spec = getDrinkSpecByDrinkId(drinkId);
                    if (!spec) continue;
                    const qty = 1;
                    lines.push({ type: 'alcohol', key: spec.id, qty });
                } else {
                    const cropId = pickOne(cropPool);
                    const crop = CROPS[cropId];
                    if (!crop) continue;
                    const qty = computeLineQty(crop.sell);
                    lines.push({ type: 'crop', key: cropId, qty });
                }
            }

            const uniqKey = (x) => `${x.type}:${x.key}`;
            const dedup = [];
            const seen = new Set();
            for (const l of lines) {
                const k = uniqKey(l);
                if (seen.has(k)) continue;
                seen.add(k);
                dedup.push(l);
            }
            if (dedup.length === 0) continue;

            let base = 0;
            dedup.forEach(l => {
                const spec = getOrderLineSpec(l);
                if (!spec) return;
                base += (Number(spec.unit || 0) || 0) * (Number(l.qty || 0) || 0);
            });
            const reward = Math.max(10, Math.round(base * 1.35 + randInt(5, 35)));

            const id = `o_${now}_${i}_${Math.floor(Math.random() * 1e6)}`;
            result.push({
                id,
                title: `è®¢å• ${i + 1}`,
                reward,
                createdAt: now,
                expiresAt: now + ORDERS.refreshMs,
                items: dedup
            });
        }

        while (result.length < count) {
            const id = `o_${now}_f_${result.length}_${Math.floor(Math.random() * 1e6)}`;
            const cropId = pickOne(Object.keys(CROPS).filter(id => id && id !== 'weed'));
            const crop = CROPS[cropId];
            const qty = computeLineQty(crop.sell);
            const reward = Math.max(10, Math.round(crop.sell * qty * 1.35 + randInt(5, 25)));
            result.push({
                id,
                title: `è®¢å• ${result.length + 1}`,
                reward,
                createdAt: now,
                expiresAt: now + ORDERS.refreshMs,
                items: [{ type: 'crop', key: cropId, qty }]
            });
        }

        return result.slice(0, count);
    }

    function renderOrders() {
        const container = document.getElementById('order-list');
        if (!container) return;

        const now = Date.now();
        if (!state.orders || typeof state.orders !== 'object') state.orders = { nextRefreshAt: 0, list: [] };
        if (!Array.isArray(state.orders.list)) state.orders.list = [];

        if (!state.orders.nextRefreshAt || state.orders.nextRefreshAt <= 0) {
            state.orders.list = generateOrders(now, ORDERS.count);
            state.orders.nextRefreshAt = now + ORDERS.refreshMs;
        }

        const remainMs = Math.max(0, (state.orders.nextRefreshAt || 0) - now);
        const remainMin = Math.floor(remainMs / 60000);
        const remainSec = Math.floor((remainMs % 60000) / 1000);
        const remainText = `${remainMin}åˆ†${String(remainSec).padStart(2, '0')}ç§’`;

        container.innerHTML = '';
        container.insertAdjacentHTML('beforeend', `<div class="section-title">ğŸ“¦ è®¢å• <span class="muted">æ¯20åˆ†é’Ÿåˆ·æ–°ï½œä¸‹æ¬¡ï¼š${remainText}</span></div>`);

        const list = state.orders.list || [];
        if (list.length === 0) {
            container.insertAdjacentHTML('beforeend', `<div style="text-align:center; color:var(--text-muted); padding:14px 0;">æš‚æ— è®¢å•</div>`);
            return;
        }

        list.forEach(o => {
            const ok = canFulfillOrder(o);
            const lines = (o.items || [])
                .map(l => {
                    const spec = getOrderLineSpec(l);
                    if (!spec) return '';
                    const have = getOwnedCountForLine(l);
                    const need = l.qty || 0;
                    const done = have >= need;
                    const s = `${spec.emoji} ${spec.name} x${need}ï¼ˆ${have}/${need}ï¼‰`;
                    return `<div class="item-sub" style="margin-top:2px; color:${done ? 'rgba(0,184,148,0.95)' : 'var(--text-muted)'};">${escapeHtml(s)}</div>`;
                })
                .join('');

            const div = document.createElement('div');
            div.className = 'list-item';
            div.innerHTML = `
                <div class="item-icon">ğŸ“¦</div>
                <div class="item-details">
                    <div class="item-name">${escapeHtml(o.title)} <span class="badge" style="background:rgba(253,203,110,0.20); border-color:rgba(211,84,0,0.16); color:rgba(211,84,0,0.9);">+${Math.floor(o.reward)}é‡‘</span></div>
                    ${lines}
                </div>
                <button class="item-action btn-buy" onclick="fulfillOrder('${o.id}')" ${ok ? '' : 'disabled'}>äº¤ä»˜</button>
            `;
            container.appendChild(div);
        });
    }

    function renderKitchen() {
        const container = document.getElementById('recipe-list');
        container.innerHTML = '';
        const visibleRecipes = RECIPES
            .map((r, idx) => ({ r, idx }))
            .filter(x => x.r && (!x.r.unlockPrice || x.r.unlocked));

        if (visibleRecipes.length === 0) {
            container.innerHTML = '<div style="text-align:center; color:var(--text-muted); padding:14px 0;">å»å•†åº—è§£é”æ›´å¤šé£Ÿè°±</div>';
            return;
        }

        visibleRecipes.sort((a, b) => {
            const ca = canCraftRecipe(a.r) ? 0 : 1;
            const cb = canCraftRecipe(b.r) ? 0 : 1;
            if (ca !== cb) return ca - cb;
            return a.idx - b.idx;
        });

        visibleRecipes.forEach(({ r, idx }) => {
            let reqStr = Object.keys(r.req).map(k => `${CROPS[k].name}x${r.req[k]}`).join(' ');
            const div = document.createElement('div');
            div.className = 'list-item';
            div.innerHTML = `
                <div class="item-icon">${r.emoji}</div>
                <div class="item-details">
                    <div class="item-name">${r.name}</div>
                    <div class="item-sub">${reqStr}</div>
                </div>
                <button class="item-action btn-buy" onclick="craft(${idx})">åˆ¶ä½œ</button>
            `;
            container.appendChild(div);
        });
    }

    // --- è¾…åŠ©åŠŸèƒ½ ---
    function selectTool(t) {
        state.tool = t;
        state.selectedSeed = null;
        updateToolsUI();
        renderInventory();
    }

    function selectSeed(id) {
        state.selectedSeed = id;
        state.tool = 'hand'; 
        updateToolsUI();
        renderInventory();
        showToast(`é€‰æ‹©äº† ${CROPS[id].name}ç§å­`);
    }

    function switchTab(tabId, tabEl) {
        document.querySelectorAll('.tab').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

        const activeTab = tabEl || document.querySelector(`.tab[data-tab="${tabId}"]`);
        if (activeTab) activeTab.classList.add('active');

        const activeContent = document.getElementById('tab-' + tabId);
        if (activeContent) activeContent.classList.add('active');

        if (tabId === 'orders') {
            renderOrders();
        }
    }

    function showToast(msg, type='normal') {
        const div = document.createElement('div');
        div.className = 'toast';
        div.innerText = msg;
        if(type==='success') div.style.borderLeft = "4px solid #55efc4";
        document.getElementById('toast-container').appendChild(div);
        
        // è§¦å‘åŠ¨ç”»
        requestAnimationFrame(() => {
            div.classList.add('show');
        });

        setTimeout(() => {
            div.classList.remove('show');
            setTimeout(() => div.remove(), 300);
        }, 2000);
    }

    function playSound(type) {
        try {
            if (!audioState.enabled) return;
            const ctx = ensureAudioContext();
            if (!ctx) return;
            if (ctx.state === 'suspended') {
                ctx.resume().catch(() => {});
            }
            const t0 = ctx.currentTime + 0.001;

            if (type === 'dig') {
                playBeep(t0, { freq: 160, toFreq: 90, dur: 0.12, gain: 0.14, wave: 'square' });
                playBeep(t0 + 0.03, { freq: 140, toFreq: 70, dur: 0.10, gain: 0.11, wave: 'square' });
                return;
            }
            if (type === 'water') {
                playBeep(t0, { freq: 520, toFreq: 380, dur: 0.08, gain: 0.10, wave: 'sine' });
                playBeep(t0 + 0.06, { freq: 460, toFreq: 300, dur: 0.09, gain: 0.08, wave: 'sine' });
                return;
            }
            if (type === 'plant') {
                playBeep(t0, { freq: 330, toFreq: 520, dur: 0.10, gain: 0.10, wave: 'triangle' });
                playBeep(t0 + 0.09, { freq: 660, toFreq: 760, dur: 0.05, gain: 0.07, wave: 'triangle' });
                return;
            }
            if (type === 'harvest') {
                playBeep(t0, { freq: 740, toFreq: 980, dur: 0.06, gain: 0.10, wave: 'triangle' });
                playBeep(t0 + 0.05, { freq: 980, toFreq: 1175, dur: 0.06, gain: 0.09, wave: 'triangle' });
                return;
            }
            if (type === 'buy') {
                playBeep(t0, { freq: 520, toFreq: 780, dur: 0.07, gain: 0.10, wave: 'sine' });
                playBeep(t0 + 0.07, { freq: 780, toFreq: 1040, dur: 0.07, gain: 0.10, wave: 'sine' });
                return;
            }
            if (type === 'coin') {
                playBeep(t0, { freq: 1040, toFreq: 1560, dur: 0.05, gain: 0.08, wave: 'sine' });
                playBeep(t0 + 0.05, { freq: 1560, toFreq: 2080, dur: 0.04, gain: 0.06, wave: 'sine' });
                return;
            }
            if (type === 'craft') {
                playBeep(t0, { freq: 392, toFreq: 523, dur: 0.08, gain: 0.10, wave: 'triangle' });
                playBeep(t0 + 0.08, { freq: 523, toFreq: 659, dur: 0.08, gain: 0.10, wave: 'triangle' });
                playBeep(t0 + 0.16, { freq: 659, toFreq: 784, dur: 0.10, gain: 0.10, wave: 'triangle' });
                return;
            }
        } catch {}
    }

    const audioState = {
        enabled: true,
        ctx: null,
        master: null,
        unlocked: false
    };

    function ensureAudioContext() {
        if (audioState.ctx) return audioState.ctx;
        const AC = window.AudioContext || window.webkitAudioContext;
        if (!AC) return null;
        const ctx = new AC();
        const master = ctx.createGain();
        master.gain.value = 0.22;
        master.connect(ctx.destination);
        audioState.ctx = ctx;
        audioState.master = master;
        return ctx;
    }

    function unlockAudioOnce() {
        if (audioState.unlocked) return;
        audioState.unlocked = true;
        try {
            const ctx = ensureAudioContext();
            if (!ctx) return;
            if (ctx.state === 'suspended') ctx.resume().catch(() => {});
            playSound('coin');
        } catch {}
    }

    function loadAudioSetting() {
        try {
            const v = localStorage.getItem('pixel-farm-audio-enabled');
            if (v === '0') audioState.enabled = false;
            if (v === '1') audioState.enabled = true;
        } catch {}
    }

    function renderAudioToggle() {
        const btn = document.getElementById('audio-toggle');
        if (!btn) return;
        const on = !!audioState.enabled;
        btn.innerText = on ? 'ğŸ”Š' : 'ğŸ”‡';
        btn.title = on ? 'éŸ³æ•ˆï¼šå¼€' : 'éŸ³æ•ˆï¼šå…³';
        btn.setAttribute('aria-label', btn.title);
    }

    function toggleAudio() {
        audioState.enabled = !audioState.enabled;
        try {
            localStorage.setItem('pixel-farm-audio-enabled', audioState.enabled ? '1' : '0');
        } catch {}
        renderAudioToggle();
        if (audioState.enabled) {
            unlockAudioOnce();
            playSound('coin');
            showToast('éŸ³æ•ˆå·²å¼€å¯', 'success');
        } else {
            showToast('éŸ³æ•ˆå·²å…³é—­');
        }
    }

    function playBeep(startAt, { freq, toFreq, dur, gain, wave }) {
        const ctx = audioState.ctx;
        const master = audioState.master;
        if (!ctx || !master) return;

        const o = ctx.createOscillator();
        const g = ctx.createGain();

        o.type = wave || 'sine';
        o.frequency.setValueAtTime(freq, startAt);
        if (typeof toFreq === 'number' && toFreq > 0) {
            o.frequency.exponentialRampToValueAtTime(Math.max(1, toFreq), startAt + Math.max(0.01, dur));
        }

        const peak = Math.max(0, Math.min(1, gain || 0.1));
        const a = 0.006;
        const r = Math.max(0.01, dur * 0.45);
        g.gain.setValueAtTime(0.0001, startAt);
        g.gain.exponentialRampToValueAtTime(Math.max(0.0002, peak), startAt + a);
        g.gain.exponentialRampToValueAtTime(0.0001, startAt + Math.max(a + 0.01, dur - r));
        g.gain.exponentialRampToValueAtTime(0.0001, startAt + dur);

        o.connect(g);
        g.connect(master);

        o.start(startAt);
        o.stop(startAt + dur + 0.02);
        o.onended = () => {
            try { o.disconnect(); } catch {}
            try { g.disconnect(); } catch {}
        };
    }

    window.onload = init;

    window.addEventListener('load', () => {
        const input = document.getElementById('save-file-input');
        if (!input) return;
        input.addEventListener('change', (e) => {
            const file = e.target.files && e.target.files[0];
            if (file) handleImportFile(file);
        });
    });

    window.addEventListener('pointerdown', unlockAudioOnce, { once: true, passive: true });
    window.addEventListener('keydown', unlockAudioOnce, { once: true, passive: true });

</script>
</body>
</html>
